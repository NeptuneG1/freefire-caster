<script>
// --- helpers you already have ---
const norm = (v) => (v==null ? '' : String(v).trim());
function looksLikeURL(v){ return /^https?:\/\//i.test(String(v||'')); }
function renderSimpleTable(list, cols){
  if (!list.length) return '<div class="muted">No rows.</div>';
  const head = `<thead><tr>${cols.map(c=>`<th class="${c.right?'right':''}">${c.label}</th>`).join('')}</tr></thead>`;
  const body = `<tbody>${list.map(r=>`<tr>${cols.map(c=>{
    let v = r[c.key];
    if (c.format==='pct') v = isFinite(v) ? (v*100).toFixed(1)+'%' : '—';
    else if (c.format==='1d') v = isFinite(v) ? Number(v).toFixed(1) : '—';
    else if (c.format==='2d') v = isFinite(v) ? Number(v).toFixed(2) : '—';
    else if (c.format==='0d') v = isFinite(v) ? Number(v).toFixed(0) : '—';
    if (c.link && v && looksLikeURL(v)) v = `<a href="${v}" target="_blank" rel="noopener">${v}</a>`;
    return `<td class="${c.right?'right':''}">${(v==null||v==='')?'—':v}</td>`;
  }).join('')}</tr>`).join('')}</tbody>`;
  return `<table>${head}${body}</table>`;
}

// ===== NEW: robust Team Info + Players loaders =====
function uiShowTeamInfoError(msg){
  const box = document.getElementById('teamInfoBody');
  box.innerHTML = `<div class="muted" style="white-space:pre-wrap">${msg}</div>`;
}
function uiShowRosterError(msg){
  const box = document.getElementById('teamRosterBody');
  box.innerHTML = `<div class="muted" style="white-space:pre-wrap">${msg}</div>`;
}

function prettifyKey(k){
  return String(k).replace(/_/g,' ').replace(/\b\w/g, s=>s.toUpperCase());
}

function renderTeamInfo(info){
  const box = document.getElementById('teamInfoBody');
  if (!info){ box.innerHTML = '<div class="muted">No team info found.</div>'; return; }

  const hide = new Set(['id','created_at','updated_at','code','team_code','team','team_name','logo','logo_url','photo','image','image_url']);
  const preferred = ['country','region','founded','coach','manager','owner','org','sponsor','hq','tagline','website','twitter','facebook','youtube','instagram','tiktok','discord'];
  const keys = Object.keys(info);
  const picked = [...preferred.filter(k => keys.includes(k)), ...keys.filter(k => !preferred.includes(k) && !hide.has(k))];

  const rows = picked.map(k=>{
    let v = info[k];
    if (v == null || v === '') return '';
    if (typeof v === 'object'){ try{ v = JSON.stringify(v); }catch{} }
    if (looksLikeURL(v)) v = `<a href="${v}" target="_blank" rel="noopener">${v}</a>`;
    return `<tr><th style="width:160px;color:var(--muted);font-weight:600">${prettifyKey(k)}</th><td>${v}</td></tr>`;
  }).filter(Boolean).join('');

  const logoUrl = info.logo_url || info.logo || '';
  const maybeLogo = logoUrl ? `<div style="margin-bottom:8px"><img src="${logoUrl}" alt="team logo" style="width:84px;height:84px;object-fit:contain;border:1px solid #2a2a2a;border-radius:8px;background:#111"></div>` : '';

  box.innerHTML = `${maybeLogo}<table>${rows || '<tr><td class="muted">No visible fields.</td></tr>'}</table>`;
}

function renderRoster(players){
  const box = document.getElementById('teamRosterBody');
  if (!players || !players.length){ box.innerHTML = '<div class="muted">No players found.</div>'; return; }

  const keys = Object.keys(players[0] || {});
  const avatarKey = keys.find(k => /photo|avatar|image|picture/i.test(k)) || null;
  const ignKey    = keys.find(k => /ign|nickname|in.?game.?name|player.?name/i.test(k)) || 'name';
  const roleKey   = keys.find(k => /role|position/i.test(k)) || null;
  const countryKey= keys.find(k => /country|nation/i.test(k)) || null;
  const ageKey    = keys.find(k => /^age$/i.test(k)) || null;
  const accolKey  = keys.find(k => /accolade|achievement|title|awards/i.test(k)) || null;

  const rows = players
    .slice()
    .sort((a,b)=> String(a[roleKey]||'').localeCompare(String(b[roleKey]||'')) || String(a[ignKey]||'').localeCompare(String(b[ignKey]||'')))
    .map(p=>{
      const avatar = avatarKey && p[avatarKey] ? `<img class="avatar" src="${p[avatarKey]}" alt="">` : '';
      const ign = p[ignKey] ?? '—';
      const role = roleKey ? (p[roleKey] ?? '—') : '—';
      const country = countryKey ? (p[countryKey] ?? '—') : '—';
      const age = ageKey ? (p[ageKey] ?? '—') : '—';
      let acc = accolKey ? (p[accolKey] ?? '—') : '—';
      if (typeof acc === 'object'){ try { acc = JSON.stringify(acc); }catch{} }
      return { avatar, ign, role, country, age, acc };
    });

  box.innerHTML = renderSimpleTable(rows, [
    {label:'', key:'avatar'},
    {label:'IGN', key:'ign'},
    {label:'Role', key:'role'},
    {label:'Country', key:'country'},
    {label:'Age', key:'age', right:true},
    {label:'Accolades', key:'acc'},
  ]);
}

// Build an OR string for PostgREST `.or()` safely
function buildOr(filters){
  // filters: array of {col, op, val}; op e.g. 'ilike'
  // For ilike contains, pass val like *text*; for exact case-insens, pass val without stars.
  return filters
    .filter(f => f.val)
    .map(f => `${f.col}.${f.op}.${String(f.val).replaceAll(',', ' ')}`)
    .join(',');
}

// === UPDATED: case-insensitive, multi-column search for team info
async function fetchTeamInfoBy(codeRaw, nameRaw){
  const code = norm(codeRaw);
  const name = norm(nameRaw);
  const codeUp = code.toUpperCase();
  const nameLike = `*${name}*`;

  // 1) Try exact-ish case-insensitive matches first
  let { data, error } = await client
    .from('br_team_info')
    .select('*')
    .or(buildOr([
      {col:'code',      op:'ilike', val:codeUp},
      {col:'team_code', op:'ilike', val:codeUp},
      {col:'team',      op:'ilike', val:name},
      {col:'team_name', op:'ilike', val:name},
    ]))
    .limit(1);

  if (error){
    console.error('br_team_info error (exact-ish):', error);
    uiShowTeamInfoError(`Team info error: ${error.message || error}`);
    return null;
  }
  if (data && data.length) return data[0];

  // 2) Fallback: contains search on name fields
  let fallback = await client
    .from('br_team_info')
    .select('*')
    .or(buildOr([
      {col:'team',      op:'ilike', val:nameLike},
      {col:'team_name', op:'ilike', val:nameLike},
    ]))
    .limit(1);

  if (fallback.error){
    console.error('br_team_info error (contains):', fallback.error);
    uiShowTeamInfoError(`Team info error: ${fallback.error.message || fallback.error}`);
    return null;
  }
  return (fallback.data && fallback.data.length) ? fallback.data[0] : null;
}

// === UPDATED: case-insensitive, multi-column search for players (+team_id fallback)
async function fetchPlayersBy(codeRaw, nameRaw, teamId){
  const code = norm(codeRaw);
  const name = norm(nameRaw);
  const codeUp = code.toUpperCase();
  const nameLike = `*${name}*`;

  // 1) Try by code/name (case-insensitive)
  let { data, error } = await client
    .from('br_player_info')
    .select('*')
    .or(buildOr([
      {col:'code',      op:'ilike', val:codeUp},
      {col:'team_code', op:'ilike', val:codeUp},
      {col:'team',      op:'ilike', val:name},
      {col:'team_name', op:'ilike', val:name},
      {col:'team',      op:'ilike', val:nameLike},
      {col:'team_name', op:'ilike', val:nameLike},
    ]));

  if (error){
    console.error('br_player_info error (by code/name):', error);
    uiShowRosterError(`Player info error: ${error.message || error}`);
    return [];
  }
  if (data && data.length) return data;

  // 2) If we have a teamId column relationship, try it
  if (teamId != null){
    const res = await client.from('br_player_info').select('*').eq('team_id', teamId);
    if (res.error){
      console.error('br_player_info error (by team_id):', res.error);
      uiShowRosterError(`Player info error: ${res.error.message || res.error}`);
      return [];
    }
    if (res.data && res.data.length) return res.data;
  }

  return [];
}

// === UPDATED: load both and render, with helpful UI when blocked by RLS ===
async function loadTeamMeta(teamObj){
  const code = (teamObj.name||'').trim();
  const name = (teamObj.fullname||'').trim();

  // Fetch team info first (to possibly get team_id)
  let info = null;
  try{
    info = await fetchTeamInfoBy(code, name);
  }catch(e){
    console.error('fetchTeamInfoBy threw:', e);
    uiShowTeamInfoError(`Team info error: ${e.message || e}`);
  }
  renderTeamInfo(info);

  // Players (try with team_id when available)
  let players = [];
  try{
    const teamId = info && (info.id ?? info.team_id);
    players = await fetchPlayersBy(code, name, teamId);
  }catch(e){
    console.error('fetchPlayersBy threw:', e);
    uiShowRosterError(`Player info error: ${e.message || e}`);
  }
  renderRoster(players);
}
</script>
