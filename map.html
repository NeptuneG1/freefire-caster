<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Team Path Planner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    const client = supabase.createClient(
      'https://gkugecflfddkpitlrmws.supabase.co',
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdrdWdlY2ZsZmRka3BpdGxybXdzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDYwODMwNzQsImV4cCI6MjA2MTY1OTA3NH0.OgQOx9k71DDdK1yOa7VNKGSgoFD9kNGo8j-bR91zGKE'
    );

```
client.auth.getSession().then(({ data: { session } }) => {
  if (!session) {
    window.location.href = "index.html";
  } else {
    const userInfo = document.getElementById("user-info");
    if (userInfo && session.user?.email) {
      userInfo.textContent = "Logged in as: " + session.user.email;
    }
  }
});

function logout() {
  client.auth.signOut().then(() => {
    window.location.href = "index.html";
  });
}
```

  </script>

  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100vh; overflow: hidden;
      font-family: Arial, sans-serif;
      background: #121212; color: white;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    #main { display: flex; height: 100vh; width: 100vw; }
    #map-container {
      flex: 1; position: relative; background: black;
    }
    #map {
      width: 100%; height: 100%;
      background-size: auto 100%;
      background-position: center;
      background-repeat: no-repeat;
      position: relative;
      touch-action: none;
    }
    canvas {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
    }
    .unit {
      position: absolute; width: 30px; height: 30px;
      background: #2e2e2e; border-radius: 50%;
    }
    .unit img {
      width: 100%; height: 100%;
      box-shadow: 0 0 8px 2px rgba(255, 255, 255, 0.6);
      border-radius: 50%;
    }
    .unit-label {
      position: absolute; top: -18px; left: 0;
      font-size: 12px; background: rgba(0,0,0,0.6);
      padding: 2px 6px; border-radius: 4px;
    }
    .reset-btn {
      position: absolute; bottom: -20px; left: 0;
      background: rgba(255,255,255,0.9); color: #000;
      font-size: 10px; padding: 2px 5px;
      border: none; border-radius: 4px;
      cursor: pointer;
    }

    #sidebar {
      width: 320px;
      background: #1c1c1c;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      padding: 10px;
    }
    .icon-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      justify-items: center;
    }
    .team-icon {
      width: 55px; height: 60px;
      border: 2px solid #555;
      border-radius: 6px;
      cursor: pointer;
    }
    #controls {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding-top: 8px;
    }
    #controls button, #map-select {
      padding: 6px;
      background: #e0a84f;
      border: none;
      border-radius: 6px;
      color: white;
      font-weight: bold;
      cursor: pointer;
    }
    #draw-circle.active {
      background-color: #00ffff;
      color: #000;
    }
    #map-select {
      background: #333;
      color: #fff;
    }
    #import-file {
      display: none;
    }
    .button-row {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    .button-row button {
      flex: 1 1 auto;
      white-space: nowrap;
    }
	.button-row button {
      flex: 1;
    }  
    .note {
  position: absolute;
  background: white;
  color: black;
  border: 1px solid #333;
  padding: 0;
  font-size: 12px;
  border-radius: 6px;
  max-width: 200px;
  overflow: hidden;
}

.drag-handle {
  background: #ccc;
  padding: 2px 6px;
  font-weight: bold;
  cursor: grab;
  border-radius: 6px 6px 0 0;
  user-select: none;
}

.note div[contenteditable] {
  padding: 4px 8px;
  min-height: 20px;
}
  </style>

</head>
<body>
<div id="main">
  <div id="map-container">
    <div id="map">
      <canvas id="pathCanvas"></canvas>
    </div>
  </div>
  <div id="sidebar">
    <div class="icon-grid" id="teamIcons"></div>
    <div id="controls">
      <div class="button-row">
        <button id="draw-circle">Draw Circle</button>
        <button id="note-mode">Add Note</button>
      </div>
      <select id="map-select">
        <option value="https://i.imgur.com/V6iUHaA.jpeg">Bermuda</option>
        <option value="https://i.imgur.com/ieY0LHk.jpeg">Purgatory</option>
        <option value="https://i.imgur.com/48O1Jf8.jpeg">Alpine</option>
        <option value="https://i.imgur.com/4Yz12P9.jpeg">Kalahari</option>
        <option value="https://i.imgur.com/0MZNMJZ.jpeg">NeXTerra</option>
        <option value="https://i.imgur.com/IX1oY9Z.jpeg">Solara</option>
      </select>
      <button id="undo-btn">Undo</button>
      <button id="reset-all-btn">Reset All</button>
      <button id="export-btn">Export</button>
      <button onclick="document.getElementById('import-file').click()">Import</button>
      <input type="file" id="import-file" accept=".json" />
      <button onclick="location.href='dashboard.html'">← Back to Dashboard</button>
      <button onclick="logout()">Logout</button>
      <p id="user-info" style="font-size: 0.8rem; text-align: center; margin-top: 10px; color: #aaa;"></p>
    </div>
  </div>
</div>

<script>
const map = document.getElementById("map");
const canvas = document.getElementById("pathCanvas");
const ctx = canvas.getContext("2d");
const teamPaths = {}, teamIcons = {}, undoStacks = {}, circles = [], historyStack = [];
let selectedIcon = null, activeTeam = null;
let drawCircleMode = false, noteMode = false;
let resizingCircle = null, draggingCircle = null;
let isResizing = false, isDragging = false;
const notes = [];

const teamColors = [
  "#FF0000", "#00FF00", "#00FFFF", "#FFFF00", "#FF00FF", "#FFA500",
  "#00BFFF", "#FF69B4", "#7FFF00", "#FF4500", "#00FF7F", "#1E90FF",
  "#FFD700", "#ADFF2F", "#FF1493", "#40E0D0", "#FF6347", "#87CEEB"
];

const mapSelect = document.getElementById("map-select");
const savedMap = localStorage.getItem("selectedMap");
map.style.backgroundImage = `url('${savedMap || mapSelect.value}')`;
mapSelect.value = savedMap || mapSelect.value;
mapSelect.onchange = () => {
  map.style.backgroundImage = `url('${mapSelect.value}')`;
  localStorage.setItem("selectedMap", mapSelect.value);
};

// Team icons
const hashes = [
  "GZxPNXi","yXDnWtr","vjq0Mqn","i0VtqZ9","6pj4iPl","6eZfM0T","Ij8Dsbw",
  "3D3YNrl","NnVZy68","kTq43ai","QetHG72","cHJrJTZ","pa6Ne3B","KMgMXU2",
  "aVTdNhl","BQp28V6","6iz3apc","O6Xjkbx"
];
hashes.forEach((h, i) => {
  const wrapper = document.createElement("div");
  wrapper.style.display = "flex";
  wrapper.style.flexDirection = "column";
  wrapper.style.alignItems = "center";

  const img = document.createElement("img");
  img.src = `https://i.imgur.com/${h}.png`;
  img.className = "team-icon";
  img.dataset.id = "team" + (i + 1);
  img.onclick = () => selectedIcon = img;

  const colorBar = document.createElement("div");
  colorBar.style.width = "60%";
  colorBar.style.height = "6px";
  colorBar.style.marginTop = "5px";
  colorBar.style.borderRadius = "8px";
  colorBar.style.backgroundColor = teamColors[i] || "#fff";

  wrapper.appendChild(img);
  wrapper.appendChild(colorBar);
  document.getElementById("teamIcons").appendChild(wrapper);
});

// Draw Circle Mode Toggle
document.getElementById("draw-circle").onclick = () => {
  drawCircleMode = !drawCircleMode;
  const btn = document.getElementById("draw-circle");
  btn.textContent = drawCircleMode ? "Circle Mode: ON" : "Draw Circle";
  btn.classList.toggle("active", drawCircleMode);
};

// Note Mode Toggle
document.getElementById("note-mode").onclick = () => {
  noteMode = !noteMode;
  document.getElementById("note-mode").textContent = noteMode ? "Click on Map to Add Note" : "Add Note";
};

// Get click/touch coordinates relative to map
function getCoords(e) {
  const rect = map.getBoundingClientRect();
  const touch = e.touches ? e.touches[0] : e;
  return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
}

function createNote(x, y, text) {
  const noteDiv = document.createElement("div");
  noteDiv.className = "note";
  noteDiv.style.left = `${x}px`;
  noteDiv.style.top = `${y}px`;

  const handle = document.createElement("div");
  handle.className = "drag-handle";
  handle.textContent = "☰";

  const content = document.createElement("div");
  content.textContent = text;
  content.contentEditable = true;

  noteDiv.appendChild(handle);
  noteDiv.appendChild(content);
  map.appendChild(noteDiv);
  historyStack.push({ type: "note", element: noteDiv });
  notes.push({ x, y, text });

  let offsetX = 0, offsetY = 0, isDragging = false;

  const startDrag = (e) => {
    e.preventDefault();
    const touch = e.touches ? e.touches[0] : e;
    const rect = map.getBoundingClientRect();
    offsetX = touch.clientX - rect.left - noteDiv.offsetLeft;
    offsetY = touch.clientY - rect.top - noteDiv.offsetTop;
    isDragging = true;
  };

  const moveDrag = (e) => {
    if (!isDragging) return;
    const touch = e.touches ? e.touches[0] : e;
    const rect = map.getBoundingClientRect();
    const newX = touch.clientX - rect.left - offsetX;
    const newY = touch.clientY - rect.top - offsetY;
    noteDiv.style.left = `${newX}px`;
    noteDiv.style.top = `${newY}px`;
  };

  const endDrag = () => isDragging = false;

  handle.addEventListener("mousedown", e => {
  e.stopPropagation();
  e.preventDefault();
  startDrag(e);
});

handle.addEventListener("touchstart", e => {
  e.stopPropagation();
  e.preventDefault();
  startDrag(e);
}, { passive: false });

  window.addEventListener("mousemove", moveDrag);
  window.addEventListener("touchmove", moveDrag, { passive: false });
  window.addEventListener("mouseup", endDrag);
  window.addEventListener("touchend", endDrag);
}

// Map click handler
map.addEventListener("click", e => {
  const { x, y } = getCoords(e);

  if (noteMode) {
  const text = prompt("Enter note:");
  if (!text) return;
  createNote(x, y, text);
  noteMode = false;
  document.getElementById("note-mode").textContent = "Add Note";
  return;
  }

  if (drawCircleMode) {
    circles.push({ x, y, r: 50, color: "#00ffff" });
    historyStack.push({ type: "circle" });
    drawPaths();
	  saveMapState()
    return;
  }

  if (selectedIcon) {
    const id = selectedIcon.dataset.id;
    if (teamIcons[id]) return;

    const div = document.createElement("div");
    div.className = "unit";
    div.style.left = `${x - 15}px`;
    div.style.top = `${y - 15}px`;

    const img = selectedIcon.cloneNode(true);
    img.style.width = img.style.height = "30px";

    const label = document.createElement("div");
    label.className = "unit-label";
    label.textContent = id;

    const reset = document.createElement("button");
    reset.className = "reset-btn";
    reset.textContent = "Reset";
    reset.onclick = ev => {
      ev.stopPropagation();
      div.remove();
      delete teamPaths[id];
      delete teamIcons[id];
      delete undoStacks[id];
      drawPaths();
	    saveMapState()
    };

    div.append(img, label, reset);
    map.appendChild(div);
    div.onclick = () => activeTeam = id;

    teamPaths[id] = [{ x, y }];
    teamIcons[id] = div;
    undoStacks[id] = [];
    activeTeam = id;
    selectedIcon = null;
    historyStack.push({ type: "line", team: id });
    drawPaths();
	  saveMapState()
  } else if (activeTeam) {
    undoStacks[activeTeam].push([...teamPaths[activeTeam]]);
    teamPaths[activeTeam].push({ x, y });
    historyStack.push({ type: "line", team: activeTeam });
    drawPaths();
	  saveMapState()
  }
});

// Helpers for resizing and dragging circles
function findCircleForResize(pt) {
  for (let i = circles.length - 1; i >= 0; i--) {
    const c = circles[i];
    const dist = Math.hypot(c.x - pt.x, c.y - pt.y);
    if (Math.abs(dist - c.r) < 12) return c;
  }
  return null;
}

function findCircleForDrag(pt) {
  for (let i = circles.length - 1; i >= 0; i--) {
    const c = circles[i];
    const dist = Math.hypot(c.x - pt.x, c.y - pt.y);
    if (dist < c.r) return c;
  }
  return null;
}

function startTouch(e) {
  const pt = getCoords(e);

  // NEW: ignore touches on notes
  if (e.target.classList.contains("note")) return;

  resizingCircle = findCircleForResize(pt);
  if (resizingCircle) {
    isResizing = true;
  } else {
    draggingCircle = findCircleForDrag(pt);
    if (draggingCircle) isDragging = true;
  }
}

function moveTouch(e) {
  if (!isDragging && !isResizing) return;
  const { x, y } = getCoords(e);
  if (resizingCircle && isResizing) {
    resizingCircle.r = Math.max(10, Math.hypot(x - resizingCircle.x, y - resizingCircle.y));
  } else if (draggingCircle && isDragging) {
    draggingCircle.x = x;
    draggingCircle.y = y;
  }
  drawPaths();
	saveMapState()
}

function endTouch() {
  resizingCircle = draggingCircle = null;
  isResizing = isDragging = false;
}

// Add touch + mouse listeners
["mousedown", "touchstart"].forEach(evt => map.addEventListener(evt, startTouch));
["mousemove", "touchmove"].forEach(evt => map.addEventListener(evt, moveTouch));
["mouseup", "touchend", "touchcancel"].forEach(evt => map.addEventListener(evt, endTouch));

// Undo button
document.getElementById("undo-btn").onclick = () => {
  const last = historyStack.pop();
  if (!last) return;

  if (last.type === "circle") {
    circles.pop();
  } else if (last.type === "line") {
    const path = teamPaths[last.team];
    if (path) {
      path.pop();
      if (path.length === 0) {
        delete teamPaths[last.team];
        const icon = teamIcons[last.team];
        if (icon) icon.remove();
        delete teamIcons[last.team];
      }
    }
  } else if (last.type === "note" && last.element) {
    last.element.remove();
    const index = notes.findIndex(n =>
      parseInt(n.x) === parseInt(last.element.style.left) &&
      parseInt(n.y) === parseInt(last.element.style.top)
    );
    if (index !== -1) notes.splice(index, 1);
  }

  drawPaths();
	saveMapState()
};
// Reset all
document.getElementById("reset-all-btn").onclick = () => {
  if (!confirm("Reset all?")) return;
  Object.values(teamIcons).forEach(div => div.remove());
  [teamPaths, teamIcons, undoStacks].forEach(obj => Object.keys(obj).forEach(k => delete obj[k]));
  circles.length = 0;
  notes.length = 0;
  document.querySelectorAll(".note").forEach(n => n.remove());
  activeTeam = selectedIcon = null;
  drawPaths();
	saveMapState();
};

// Export JSON
document.getElementById("export-btn").onclick = () => {
  const data = {
    map: mapSelect.value,
    paths: teamPaths,
    circles,
    notes
  };
  const blob = new Blob([JSON.stringify(data)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "team-paths.json";
  a.click();
  URL.revokeObjectURL(url);
};

// Import JSON
document.getElementById("import-file").onchange = function () {
  const file = this.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = e => {
    const data = JSON.parse(e.target.result);
    if (data.map) {
      mapSelect.value = data.map;
      map.style.backgroundImage = `url('${data.map}')`;
    }

    [teamPaths, teamIcons, undoStacks].forEach(obj => Object.keys(obj).forEach(k => delete obj[k]));
    Object.values(teamIcons).forEach(div => div.remove());
    circles.length = 0;
    document.querySelectorAll(".note").forEach(n => n.remove());
    notes.length = 0;

    Object.entries(data.paths || {}).forEach(([id, points]) => {
      const icon = document.querySelector(`.team-icon[data-id="${id}"]`);
      if (!icon || !points.length) return;
      const first = points[0];
      const div = document.createElement("div");
      div.className = "unit";
      div.style.left = `${first.x - 15}px`;
      div.style.top = `${first.y - 15}px`;

      const img = icon.cloneNode(true);
      img.style.width = img.style.height = "30px";

      const label = document.createElement("div");
      label.className = "unit-label";
      label.textContent = id;

      const reset = document.createElement("button");
      reset.className = "reset-btn";
      reset.textContent = "Reset";
      reset.onclick = ev => {
        ev.stopPropagation();
        div.remove();
        delete teamPaths[id];
        delete teamIcons[id];
        delete undoStacks[id];
        drawPaths();
	      saveMapState()
      };

      div.append(img, label, reset);
      map.appendChild(div);
      div.onclick = () => activeTeam = id;
      teamPaths[id] = points;
      undoStacks[id] = [];
      teamIcons[id] = div;
    });

    data.circles?.forEach(c => circles.push(c));

    if (data.notes) {
      data.notes.forEach(n => {
        const noteDiv = document.createElement("div");
        noteDiv.className = "note";
        noteDiv.textContent = n.text;
        noteDiv.style.left = `${n.x}px`;
        noteDiv.style.top = `${n.y}px`;
        map.appendChild(noteDiv);
        notes.push(n);
      });
    }

    drawPaths();
	saveMapState()
  };
  reader.readAsText(file);
};

// Drawing functions
function drawArrow(from, to, color) {
  const dx = to.x - from.x, dy = to.y - from.y;
  const angle = Math.atan2(dy, dx);
  ctx.beginPath();
  ctx.shadowColor = color;
  ctx.shadowBlur = 6;
  ctx.moveTo(from.x, from.y);
  ctx.lineTo(to.x, to.y);
  ctx.lineTo(to.x - 10 * Math.cos(angle - Math.PI / 6), to.y - 10 * Math.sin(angle - Math.PI / 6));
  ctx.moveTo(to.x, to.y);
  ctx.lineTo(to.x - 10 * Math.cos(angle + Math.PI / 6), to.y - 10 * Math.sin(angle + Math.PI / 6));
  ctx.strokeStyle = color;
  ctx.lineWidth = 4;
  ctx.stroke();
}

function drawPaths() {
  canvas.width = map.clientWidth;
  canvas.height = map.clientHeight;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (let c of circles) {
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r, 0, 2 * Math.PI);
    ctx.strokeStyle = c.color;
    ctx.setLineDash([3, 1]);
    ctx.lineWidth = 5;
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.beginPath();
    ctx.arc(c.x + c.r, c.y, 4, 0, 2 * Math.PI);
    ctx.fillStyle = c.color;
    ctx.fill();
  }

  for (let id in teamPaths) {
    const path = teamPaths[id];
    const i = parseInt(id.replace("team", "")) - 1;
    const color = teamColors[i] || "#fff";
    for (let j = 0; j < path.length - 1; j++) {
      drawArrow(path[j], path[j + 1], color);
    }
  }
}

window.addEventListener("resize", drawPaths);
drawPaths();

let mapState = {};

// Load map state from Supabase
async function loadMapState() {
  const { data, error } = await client.from('map').select('state').eq('id', 1).single();
  if (error) {
    console.error('❌ Failed to load map state:', error);
  } else if (data?.state) {
    applyMapState(data.state);
    console.log('✅ Map state loaded');
  }
}

// Save map state to Supabase
async function saveMapState() {
  const state = {
    map: mapSelect.value,
    paths: teamPaths,
    circles,
    notes
  };
  const { error } = await client
    .from('map')
    .update({ state, updated_at: new Date().toISOString() })
    .eq('id', 1);

  if (error) {
    console.error('❌ Failed to save map state:', error);
  } else {
    console.log('✅ Map state saved');
  }
}

// Apply state to UI
function applyMapState(state) {
  mapSelect.value = state.map || mapSelect.value;
  map.style.backgroundImage = `url('${mapSelect.value}')`;

  // Reset old data
  [teamPaths, teamIcons, undoStacks].forEach(obj => Object.keys(obj).forEach(k => delete obj[k]));
  Object.values(teamIcons).forEach(div => div.remove());
  circles.length = 0;
  notes.length = 0;
  document.querySelectorAll(".note").forEach(n => n.remove());

  // Load teams
  Object.entries(state.paths || {}).forEach(([id, points]) => {
    const icon = document.querySelector(`.team-icon[data-id="${id}"]`);
    if (!icon || !points.length) return;
    const first = points[0];
    const div = document.createElement("div");
    div.className = "unit";
    div.style.left = `${first.x - 15}px`;
    div.style.top = `${first.y - 15}px`;
    const img = icon.cloneNode(true);
    img.style.width = img.style.height = "30px";
    const label = document.createElement("div");
    label.className = "unit-label";
    label.textContent = id;
    const reset = document.createElement("button");
    reset.className = "reset-btn";
    reset.textContent = "Reset";
    reset.onclick = ev => {
      ev.stopPropagation();
      div.remove();
      delete teamPaths[id];
      delete teamIcons[id];
      delete undoStacks[id];
      drawPaths();
    };
    div.append(img, label, reset);
    map.appendChild(div);
    div.onclick = () => activeTeam = id;
    teamPaths[id] = points;
    undoStacks[id] = [];
    teamIcons[id] = div;
  });

  // Load circles
  (state.circles || []).forEach(c => circles.push(c));

  // Load notes
  (state.notes || []).forEach(n => createNote(n.x, n.y, n.text));
  drawPaths();
}

// Real-time sync
client.channel('public:map')
  .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'map' }, payload => {
    if (payload.new.id === 1) {
      applyMapState(payload.new.state);
      console.log('🔄 Map state synced');
    }
  })
  .subscribe();

// Call load on page load
window.addEventListener("DOMContentLoaded", loadMapState);
</script>

</body>
</html>
