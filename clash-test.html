<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Clash Squad — Skills Report & Summary</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    :root{
      --bg:#0e0e0e; --panel:#1b1b1b; --panel2:#141414;
      --ink:#f5f5f5; --muted:#b9b9b9; --brand:#ffbd59; --brand2:#ff7733;
      --line:#313131; --good:#71d083; --bad:#ff6b6b;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Ubuntu,Arial,sans-serif;background:var(--bg);color:var(--ink)}
    header{position:sticky;top:0;z-index:5;background:#1f1f1f;border-bottom:3px solid var(--brand);padding:14px 16px}
    h1{margin:0;font-size:1.25rem;letter-spacing:.3px;color:var(--brand)}
    .user-controls{position:absolute;right:16px;top:12px;display:flex;gap:10px;align-items:center}
    .chip{font-size:.85rem;color:#ddd}
    .btn{background:var(--brand);color:#1b1b1b;border:0;border-radius:8px;padding:8px 12px;font-weight:700;cursor:pointer;text-decoration:none;display:inline-block}
    .btn:hover{background:#e6a74f}
    .shell{max-width:1200px;margin:22px auto;padding:0 12px}
    .bar{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-bottom:12px}

    .block{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:14px;margin-bottom:16px}
    .block h2{margin:0 0 10px 0;color:var(--brand)}
    .controls{display:flex;flex-wrap:wrap;gap:8px;margin:4px 0 10px}
    .controls label{display:flex;align-items:center;gap:6px;background:var(--panel2);border:1px solid var(--line);padding:6px 8px;border-radius:8px}
    .controls select,.controls input[type="date"],.controls input[type="text"]{background:#212121;color:var(--brand);border:1px solid #3a3a3a;border-radius:6px;padding:6px 8px}
    .muted{color:var(--muted);font-size:.9rem}

    /* Tabs */
    .tabs{display:flex;gap:8px;margin:8px 0 12px}
    .tab{background:#212121;color:#ddd;border:1px solid #333;border-radius:8px;padding:6px 10px;cursor:pointer}
    .tab.active{background:var(--brand);color:#1b1b1b;border-color:var(--brand)}
    .js-section{display:none}
    .js-section.active{display:block}

    table{width:100%;border-collapse:collapse}
    th,td{border-bottom:1px solid var(--line);padding:8px;vertical-align:top}
    thead th{background:#191919;text-align:left}
    tbody tr:hover{background:#141414}
    .wl{font-weight:700;padding:2px 8px;border-radius:999px;display:inline-block}
    .wl.W{background:#193e2b;color:var(--good);border:1px solid #245b3e}
    .wl.L{background:#401e1e;color:var(--bad);border:1px solid #6b2c2c}

    /* Players as 2x2 grid */
    .playersWrap{
      display:grid;
      grid-template-columns: repeat(2, minmax(240px, 1fr));
      grid-auto-rows: auto;
      gap:10px;
      overflow:visible;
      padding-bottom:0;
    }
    .pCard{
      display:flex; align-items:center; gap:10px;
      background:#141414; border:1px solid #2a2a2a; border-radius:10px;
      padding:6px 8px;
      width:100%;
      min-width:0;
    }
    .pAct{
      width:44px; height:44px; object-fit:cover; border-radius:8px;
      border:1px solid #333; background:#0f0f0f; flex:0 0 44px;
    }
    .pPassCol{display:flex; flex-direction:column; gap:3px}
    .pPassRow{display:flex; align-items:center; gap:6px}
    .pPassRow img{
      width:14px; height:14px; object-fit:cover; border-radius:3px;
      border:1px solid #333; background:#0f0f0f;
    }
    .pPassRow span{
      font-size:.76rem; color:#bbb; max-width:120px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .pInfo{display:flex; flex-direction:column; gap:2px; min-width:0; line-height:1.2}
    .pName{font-weight:700; font-size:.92rem}
    .pHero{font-size:.86rem; color:#d8d8d8}

    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:12px}
    .card{background:var(--panel2);border:1px solid var(--line);border-radius:12px;padding:12px}
    .card h3{margin:0 0 6px 0;color:var(--brand2);font-size:1.05rem}
    .kpis{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
    .kpi{background:#111;border:1px solid #2a2a2a;border-radius:8px;padding:6px 8px;font-size:.9rem}
    .sum-table{width:100%;border-collapse:collapse;font-size:.92rem}
    .sum-table th,.sum-table td{border-bottom:1px solid #2a2a2a;padding:6px 6px}
    .right{text-align:right}
    .tight{line-height:1.25}
    .caption{margin:4px 0 10px 0}

    /* Per-Skill Table */
    #skillStats { width:90%; max-width:1200px; margin:40px auto; }
    #skillStats h2 { text-align:center; color:#ffbd59; }
    .skill-controls{
      display:flex; gap:10px; justify-content:center; align-items:center;
      flex-wrap:wrap; margin-bottom:10px;
    }
    .skill-controls select, .skill-controls button{
      background:#2a2a2a; color:#ffbd59; border:1px solid #555; border-radius:6px; padding:6px 8px;
      font-weight:700; cursor:pointer;
    }
    .skill-controls button{ background:#ff7733; color:#fff; border:none; }
    .skill-controls button:hover{ background:#e36b2e; }
    table.skill-table{ width:100%; border-collapse:collapse; }
    table.skill-table th, table.skill-table td{
      border-bottom:1px solid #333; padding:8px; text-align:left; font-size:13px;
      vertical-align:middle;
    }
    table.skill-table th{ background:#181818; position:sticky; top:0; z-index:1; }
    .skill-cell{ display:flex; align-items:center; gap:10px; }
    .skill-cell img{
      width:28px; height:28px; object-fit:cover; border-radius:6px; background:#111; border:1px solid #333;
    }
    .skill-name{ color:#eee; font-weight:600; }
    .mono{ font-variant-numeric: tabular-nums; }

    /* Compact / passive-name-hide modes */
    body.compact .block{padding:10px}
    body.compact .card{padding:8px}
    body.compact table th, body.compact table td{padding:6px}
    body.compact .pAct{width:32px;height:32px}
    body.compact .pPassRow span{max-width:90px;font-size:.7rem}
    body.compact .pName{font-size:.85rem}
    body.compact .pHero{font-size:.78rem}
    body.passive-hidden .pPassRow span{visibility:hidden}
    body.passive-hidden .pCard:hover .pPassRow span{visibility:visible}

    @media (max-width: 900px){
      .playersWrap{ grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Clash Squad — Skills Report & Summary</h1>
    <div class="user-controls">
      <span class="chip" id="user-info">Checking login…</span>
      <button class="btn" id="logoutBtn">Logout</button>
    </div>
  </header>

  <div class="shell">
    <!-- Top bar -->
    <div class="bar">
      <a href="dashboard.html" class="btn">← Back to Dashboard</a>
      <label class="muted" style="margin-left:auto">
        <input type="checkbox" id="compactToggle"> Compact mode
      </label>
      <label class="muted">
        <input type="checkbox" id="hidePassiveToggle"> Hide passive names until hover
      </label>
    </div>

    <!-- FILTERS -->
    <div class="block">
      <h2>Filters</h2>
      <div class="controls">
        <label>From
          <input type="date" id="fFrom">
        </label>
        <label>To
          <input type="date" id="fTo">
        </label>
        <label>Map
          <select id="fMap">
            <option value="__ALL__">All maps</option>
            <option value="Bermuda">Bermuda</option>
            <option value="Kalahari">Kalahari</option>
            <option value="Purgatory">Purgatory</option>
            <option value="Alpine">Alpine</option>
            <option value="Nexterra">Nexterra</option>
            <option value="Solara">Solara</option>
          </select>
        </label>
        <label>Team
          <select id="fTeam"></select>
        </label>
        <label>Tournament
          <select id="fTourn"></select>
        </label>
        <label>Outcome
          <select id="fWL">
            <option value="__ALL__">All</option>
            <option value="W">Wins only</option>
            <option value="L">Losses only</option>
          </select>
        </label>
        <button class="btn" id="applyBtn">Apply</button>
      </div>
      <div class="muted" id="filterMeta">—</div>

      <!-- Tabs -->
      <div class="tabs">
        <button data-tab="match" class="tab active">Matches</button>
        <button data-tab="summary" class="tab">Summary</button>
        <button data-tab="teammap" class="tab">Team × Map</button>
        <button data-tab="skillsbymap" class="tab">Skills by Map</button>
        <button data-tab="perskill" class="tab">Per-Skill</button>
      </div>
    </div>

    <!-- MATCH LIST -->
    <div id="sec-match" class="block js-section active">
      <h2>Per-Match Team Rows</h2>
      <table>
        <thead>
          <tr>
            <th>Date</th>
            <th>Game</th>
            <th>Map</th>
            <th>Team</th>
            <th>Opponent</th>
            <th>Score</th>
            <th>Result</th>
            <th>Ban</th>
            <th>Players (Active + 3×Passive)</th>
          </tr>
        </thead>
        <tbody id="rowsBody"></tbody>
      </table>
      <div id="rowsPager" class="bar" style="justify-content:space-between;"></div>
    </div>

    <!-- SUMMARY -->
    <div id="sec-summary" class="block js-section">
      <h2>Summary: Picks/Bans</h2>
      <div class="controls sum-controls">
        <label class="muted">Group by
          <select id="sumGroupBy">
            <option value="team">Team</option>
            <option value="player" selected>Player</option>
          </select>
        </label>
        <label class="muted">Subject
          <select id="sumKind">
            <option value="active">Active skills</option>
            <option value="passive">Passive skills</option>
            <option value="ban">Bans</option>
          </select>
        </label>
        <label class="muted">Card order
          <select id="sumCardSort">
            <option value="subjectAppear" selected>Appearances</option>
            <option value="subjectRate">Appear Rate</option>
            <option value="subjectWinrate">Win %</option>
            <option value="matches">Matches</option>
            <option value="wins">Wins</option>
            <option value="winpct">Overall Win %</option>
            <option value="name">A→Z</option>
          </select>
        </label>
        <label class="muted">Card dir
          <select id="sumCardDir">
            <option value="desc" selected>Desc</option>
            <option value="asc">Asc</option>
          </select>
        </label>
        <label class="muted">Skills order
          <select id="sumSkillSort">
            <option value="appearRate" selected>Rate</option>
            <option value="count">Count</option>
            <option value="winrate">Win %</option>
            <option value="name">A→Z</option>
          </select>
        </label>
        <label class="muted">Skills dir
          <select id="sumSkillDir">
            <option value="desc" selected>Desc</option>
            <option value="asc">Asc</option>
          </select>
        </label>
      </div>
      <div class="caption muted" id="sumMeta">—</div>
      <div class="grid" id="sumGrid"></div>
    </div>

    <!-- TEAM × MAP WIN RATE -->
    <div id="sec-teammap" class="block js-section">
      <h2>Per Team × Map Win Rate</h2>
      <div class="controls">
        <label>Sort
          <select id="tmSort">
            <option value="matches" selected>Matches</option>
            <option value="winpct">Win %</option>
            <option value="wins">Wins</option>
            <option value="team">Team</option>
            <option value="map">Map</option>
          </select>
        </label>
        <label>Dir
          <select id="tmDir">
            <option value="desc" selected>Desc</option>
            <option value="asc">Asc</option>
          </select>
        </label>
      </div>
      <div class="muted" id="tmMeta">—</div>
      <table>
        <thead>
          <tr>
            <th>Team</th><th>Map</th><th>Matches</th><th>Wins</th><th>Win %</th>
          </tr>
        </thead>
        <tbody id="tmBody"></tbody>
      </table>
    </div>

    <!-- SKILLS SUMMARY BY MAP -->
    <div id="sec-skillsbymap" class="block js-section">
      <h2>Skills Summary by Map</h2>
      <div class="controls">
        <label class="muted">Group by
          <select id="ssGroupBy">
            <option value="team" selected>Team</option>
            <option value="player">Player</option>
          </select>
        </label>
        <label class="muted">Subject
          <select id="ssKind">
            <option value="active" selected>Active</option>
            <option value="passive">Passive</option>
            <option value="ban">Ban</option>
          </select>
        </label>
        <label class="muted">Card order
          <select id="ssCardSort">
            <option value="subjectAppear" selected>Appearances</option>
            <option value="subjectRate">Appear Rate</option>
            <option value="subjectWinrate">Win %</option>
            <option value="matches">Matches</option>
            <option value="wins">Wins</option>
            <option value="winpct">Overall Win %</option>
            <option value="name">A→Z</option>
          </select>
        </label>
        <label class="muted">Card dir
          <select id="ssCardDir">
            <option value="desc" selected>Desc</option>
            <option value="asc">Asc</option>
          </select>
        </label>
        <label class="muted">Skills order
          <select id="ssSkillSort">
            <option value="appearRate" selected>Rate</option>
            <option value="count">Count</option>
            <option value="winrate">Win %</option>
            <option value="name">A→Z</option>
          </select>
        </label>
        <label class="muted">Skills dir
          <select id="ssSkillDir">
            <option value="desc" selected>Desc</option>
            <option value="asc">Asc</option>
          </select>
        </label>
      </div>
      <div class="caption muted" id="ssMeta">—</div>
      <div id="ssWrap"></div>
    </div>

    <!-- PER-SKILL -->
    <div id="sec-perskill" class="block js-section">
      <h2>Per-Skill Stats</h2>
      <div class="skill-controls">
        <label>Type
          <select id="skillTypeSelect">
            <option value="active" selected>Active</option>
            <option value="passive">Passive</option>
          </select>
        </label>
        <label>Sort by
          <select id="skillSortBy">
            <option value="picks" selected>Picks</option>
            <option value="pickRate">Pick %</option>
            <option value="bans">Bans</option>
            <option value="banRate">Ban %</option>
            <option value="wins">Wins</option>
            <option value="winRate">Win %</option>
            <option value="name">Name</option>
          </select>
        </label>
        <label>Order
          <select id="skillSortDir">
            <option value="desc" selected>Desc</option>
            <option value="asc">Asc</option>
          </select>
        </label>
        <button onclick="computeSkillStats()">Compute</button>
      </div>

      <div id="skillStatsMeta" class="muted">—</div>

      <table class="skill-table" style="margin-top:8px;">
        <thead>
          <tr>
            <th>Skill</th>
            <th>Picks</th>
            <th>Pick&nbsp;%</th>
            <th>Bans</th>
            <th>Ban&nbsp;%</th>
            <th>Wins</th>
            <th>Win&nbsp;%</th>
          </tr>
        </thead>
        <tbody id="skillStatsBody"></tbody>
      </table>
    </div>
  </div>

<script>
/* ========= Supabase init + auth ========= */
const client = supabase.createClient(
  'https://gkugecflfddkpitlrmws.supabase.co',
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdrdWdlY2ZsZmRka3BpdGxybXdzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDYwODMwNzQsImV4cCI6MjA2MTY1OTA3NH0.OgQOx9k71DDdK1yOa7VNKGSgoFD9kNGo8j-bR91zGKE'
);

(async () => {
  const { data: { session } } = await client.auth.getSession();
  if (!session) {
    window.location.href = "index.html";
    return;
  }
  const ui = document.getElementById('user-info');
  if (ui && session.user?.email) ui.textContent = `Logged in as: ${session.user.email}`;
})();
document.getElementById('logoutBtn').onclick = async () => {
  await client.auth.signOut();
  window.location.href = "index.html";
};

/* ========= Utilities ========= */
const PLACEHOLDER = 'https://imgur.com/AdvPwAO.png';
const fmtPct = (num) => isFinite(num) ? (num*100).toFixed(1) + '%' : '—';
const pct = (num, den) => den ? fmtPct(num/den) : '—';
const uniq = (arr) => [...new Set(arr)];
function ymd(d){
  const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), da=String(d.getDate()).padStart(2,'0');
  return `${y}-${m}-${da}`;
}

/* ========= State ========= */
let RAW_RECORDS = [];
let CURRENT_ROWS = [];
let PAGE_SIZE = 25;
let PAGE = 1;

/* ========= DOM ========= */
const el = (id) => document.getElementById(id);

/* ========= Init filters ========= */
(function initFilters(){
  const today = new Date();
  const from = new Date(today); from.setDate(from.getDate()-30);
  el('fFrom').value = ymd(from);
  el('fTo').value = ymd(today);
  el('fMap').value = '__ALL__';
  el('fWL').value = '__ALL__';
  const t = el('fTourn');
  if (t) t.innerHTML = `<option value="__ALL__">All tournaments</option>`;
})();

/* ========= Mode toggles ========= */
el('compactToggle')?.addEventListener('change', (e)=>{
  document.body.classList.toggle('compact', e.target.checked);
});
el('hidePassiveToggle')?.addEventListener('change', (e)=>{
  document.body.classList.toggle('passive-hidden', e.target.checked);
});

/* ========= Fetch & build ========= */
async function fetchRecords(){
  const from = el('fFrom').value;
  const to   = el('fTo').value;
  const map  = el('fMap').value;
  const team = el('fTeam').value || '__ALL__';
  const tourn= el('fTourn').value || '__ALL__';

  let q = client
    .from('draft_records')
    .select('id, match_date, game_number, team_left, team_right, team_left_score, team_right_score, map, tournament_name, state')
    .gte('match_date', from).lte('match_date', to)
    .order('match_date', { ascending:false })
    .order('id', { ascending:false });

  if (map !== '__ALL__') q = q.eq('map', map);
  if (team && team !== '__ALL__') q = q.or(`team_left.eq.${team},team_right.eq.${team}`);
  if (tourn && tourn !== '__ALL__') q = q.eq('tournament_name', tourn);

  const { data, error } = await q;
  if (error) {
    console.error('Fetch error', error);
    alert('Failed to load records');
    return [];
  }
  return data || [];
}

function populateTeamDropdown(records){
  const teams = new Set();
  records.forEach(r => { teams.add(r.team_left); teams.add(r.team_right); });
  const dd = el('fTeam');
  const prior = dd.value || '__ALL__';
  dd.innerHTML = '';
  const all = document.createElement('option'); all.value='__ALL__'; all.textContent='All teams';
  dd.appendChild(all);
  [...teams].sort().forEach(t => {
    const o=document.createElement('option'); o.value=t; o.textContent=t; dd.appendChild(o);
  });
  dd.value = prior;
}

function populateTournamentDropdown(records){
  const tourns = new Set();
  records.forEach(r => { if (r.tournament_name) tourns.add(r.tournament_name); });
  const dd = el('fTourn');
  const prior = dd.value || '__ALL__';
  dd.innerHTML = '';
  const all = document.createElement('option'); all.value='__ALL__'; all.textContent='All tournaments';
  dd.appendChild(all);
  [...tourns].sort().forEach(tn => {
    const o=document.createElement('option'); o.value=tn; o.textContent=tn; dd.appendChild(o);
  });
  dd.value = prior;
}

/* Build per-team rows from a record */
function explodeRecordToRows(rec){
  const s = rec.state || {};
  const picks = s.picks || [];
  const passives = s.passives || [];
  const bans = s.bans || [];
  const names = s.playerCards || [];

  const leftWin = (rec.team_left_score ?? 0) > (rec.team_right_score ?? 0);
  const rightWin = (rec.team_right_score ?? 0) > (rec.team_left_score ?? 0);

  function sideRow(side){
    const isLeft = side==='L';
    const team   = isLeft ? rec.team_left : rec.team_right;
    const opp    = isLeft ? rec.team_right : rec.team_left;
    const tScore = isLeft ? rec.team_left_score : rec.team_right_score;
    const oScore = isLeft ? rec.team_right_score : rec.team_left_score;
    const res    = (isLeft ? leftWin : rightWin) ? 'W' : 'L';
    const banObj = bans[ isLeft ? 0 : 1 ];
    const ban    = banObj?.name || '';
    const banImg = banObj?.image_url || '';

    const idx = isLeft ? [0,1,2,3] : [7,6,5,4];

    const actives = idx.map((i, k) => {
      const player = (names[i] && String(names[i]).trim()) ? names[i].trim() : `P${k+1}`;
      const heroObj= picks[i] || null;
      return { player, hero: heroObj?.name || '', heroImg: heroObj?.image_url || PLACEHOLDER };
    });

    const passiveLines = idx.map((i, k) => {
      const player = (names[i] && String(names[i]).trim()) ? names[i].trim() : `P${k+1}`;
      const trioObjs = (passives[i] || []).filter(Boolean).map(ps => ({
        name: ps?.name || '',
        img : ps?.image_url || PLACEHOLDER
      }));
      while (trioObjs.length < 3) trioObjs.push({name:'', img: PLACEHOLDER});
      return { player, trio: trioObjs.slice(0,3) };
    });

    return {
      rec_id: rec.id,
      match_date: rec.match_date,
      game_number: rec.game_number,
      map: rec.map,
      team, opponent: opp,
      team_score: tScore ?? 0,
      opp_score: oScore ?? 0,
      result: res,
      banName: ban,
      banImg,
      actives,
      passives: passiveLines
    };
  }

  return [sideRow('L'), sideRow('R')];
}

function applyRowFilters(allRows){
  const wl = el('fWL').value;
  const team = el('fTeam').value || '__ALL__';
  let rows = allRows.slice();

  if (team !== '__ALL__') rows = rows.filter(r => r.team === team);
  if (wl !== '__ALL__') rows = rows.filter(r => r.result === wl);
  return rows;
}

/* Player card HTML */
function playerCardHTML(player, heroName, heroImg, trio){
  const passRows = (trio || [])
    .filter(ps => ps && ps.name)
    .map(ps => `
      <div class="pPassRow">
        <img src="\${ps.img || PLACEHOLDER}" alt="\${ps.name}" loading="lazy">
        <span>\${ps.name}</span>
      </div>
    `).join('');

  const img  = heroImg || PLACEHOLDER;
  const hero = heroName || '—';
  const p    = player || '';

  return `
    <div class="pCard">
      <img class="pAct" src="\${img}" alt="\${hero}" loading="lazy">
      <div class="pPassCol">
        \${passRows || ''}
      </div>
      <div class="pInfo">
        <div class="pName">\${p}</div>
        <div class="pHero">\${hero}</div>
      </div>
    </div>
  `;
}

function renderRows(rows){
  const body = el('rowsBody');
  body.innerHTML = '';
  if (!rows.length){
    const tr=document.createElement('tr');
    const td=document.createElement('td'); td.colSpan=9; td.className='muted'; td.textContent='No rows for your selection.';
    tr.appendChild(td); body.appendChild(tr); return;
  }

  rows.forEach(r => {
    const tr=document.createElement('tr');

    const tdDate = `<td>\${r.match_date}</td>`;
    const tdGame = `<td>Game \${r.game_number}</td>`;
    const tdMap  = `<td>\${r.map}</td>`;
    const tdTeam = `<td class="tight"><div><strong>\${r.team}</strong></div><div class="muted">vs \${r.opponent}</div></td>`;
    const tdOpp  = `<td>\${r.opponent}</td>`;
    const tdScore= `<td>\${r.team_score} - \${r.opp_score}</td>`;
    const tdRes  = `<td><span class="wl \${r.result}">\${r.result}</span></td>`;

    const banImg = r.banImg || PLACEHOLDER;
    const banTxt = r.banName || '—';
    const tdBan  = `<td><div style="display:flex;align-items:center;gap:6px;">
                      <img src="\${banImg}" alt="\${banTxt}" style="width:28px;height:28px;border-radius:6px;border:1px solid #333;background:#0f0f0f" loading="lazy">
                      <span>\${banTxt}</span>
                    </div></td>`;

    const byPlayer = r.actives.map(a => {
      const p = r.passives.find(pp => pp.player === a.player) || { trio: [] };
      return playerCardHTML(a.player, a.hero, a.heroImg, p.trio);
    }).join('');

    const tdPlayers = `<td><div class="playersWrap">\${byPlayer}</div></td>`;

    tr.innerHTML = tdDate + tdGame + tdMap + tdTeam + tdOpp + tdScore + tdRes + tdBan + tdPlayers;
    body.appendChild(tr);
  });
}

/* ========== Pagination for match rows ========== */
function renderRowsPaged(rows){
  const total = rows.length;
  const pages = Math.max(1, Math.ceil(total / PAGE_SIZE));
  PAGE = Math.min(Math.max(1, PAGE), pages);
  const start = (PAGE-1)*PAGE_SIZE;
  const slice = rows.slice(start, start + PAGE_SIZE);
  renderRows(slice);
  el('rowsPager').innerHTML =
    `<div class="muted">Page \${PAGE}/\${pages} • \${total} rows</div>
     <div style="display:flex;gap:6px;">
       <button class="btn" \${PAGE<=1?'disabled':''} onclick="PAGE=1;renderRowsPaged(CURRENT_ROWS)">« First</button>
       <button class="btn" \${PAGE<=1?'disabled':''} onclick="PAGE--;renderRowsPaged(CURRENT_ROWS)">‹ Prev</button>
       <button class="btn" \${PAGE>=pages?'disabled':''} onclick="PAGE++;renderRowsPaged(CURRENT_ROWS)">Next ›</button>
       <button class="btn" \${PAGE>=pages?'disabled':''} onclick="PAGE=\${pages};renderRowsPaged(CURRENT_ROWS)">Last »</button>
     </div>`;
}

/* ===== Summary (global) ===== */
function buildBucketsFromRows(rows, groupBy, kind){
  const buckets = new Map();
  rows.forEach(r => {
    const keys = (groupBy === 'team') ? [r.team] : uniq(r.actives.map(a => a.player)).filter(Boolean);
    keys.forEach(key => {
      if (!buckets.has(key)){
        buckets.set(key, { name:key, matches:0, wins:0, skills:new Map() });
      }
      const B = buckets.get(key);
      B.matches += 1;
      if (r.result === 'W') B.wins += 1;

      if (kind === 'active'){
        r.actives.forEach(a => {
          if (groupBy==='player' && a.player !== key) return;
          const nm = a.hero; if (!nm) return;
          const S = B.skills.get(nm) || { occ:0, appear:0, appearWins:0 };
          S.occ += 1; S.appear += 1; if (r.result === 'W') S.appearWins += 1;
          B.skills.set(nm, S);
        });
      } else if (kind === 'passive'){
        r.passives.forEach(p => {
          if (groupBy==='player' && p.player !== key) return;
          (p.trio || []).forEach(x => {
            const nm = x?.name || ''; if (!nm) return;
            const S = B.skills.get(nm) || { occ:0, appear:0, appearWins:0 };
            S.occ += 1; S.appear += 1; if (r.result === 'W') S.appearWins += 1;
            B.skills.set(nm, S);
          });
        });
      } else {
        const nm = r.banName; if (!nm) return;
        const S = B.skills.get(nm) || { occ:0, appear:0, appearWins:0 };
        S.occ += 1; S.appear += 1; if (r.result === 'W') S.appearWins += 1;
        B.skills.set(nm, S);
      }
    });
  });
  return buckets;
}

function renderSummary(buckets, groupBy, kind){
  const grid = el('sumGrid');
  const meta = el('sumMeta');
  const totalEntities = buckets.size;
  const totalRows = CURRENT_ROWS.length;
  const rateLabel = (kind === 'ban') ? 'Ban Rate' : 'Pick Rate';
  meta.textContent = `${totalEntities} ${groupBy === 'team' ? 'team' : 'player'} group(s) • ${totalRows} team-row(s) in view`;

  if (!totalEntities){
    grid.innerHTML = `<div class="card"><div class="muted">No data for this selection.</div></div>`;
    return;
  }

  const cardSort  = el('sumCardSort').value;
  const cardDir   = el('sumCardDir').value;
  const skillSort = el('sumSkillSort').value;
  const skillDir  = el('sumSkillDir').value;

  const ordered = [...buckets.values()].map(b => {
    const subj = [...b.skills.values()].reduce((acc, s) => {
      acc.appear     += (s.appear || 0);
      acc.appearWins += (s.appearWins || 0);
      acc.occ        += (s.occ || 0);
      return acc;
    }, { appear:0, appearWins:0, occ:0 });
    subj.rate    = b.matches ? (subj.appear / b.matches) : 0;
    subj.winrate = subj.appear ? (subj.appearWins / subj.appear) : 0;
    b._subj = subj;
    return b;
  });

  const cardCmp = (a, b) => {
    let A,B;
    if (cardSort==='name'){ A=a.name?.toLowerCase()||''; B=b.name?.toLowerCase()||''; }
    else if (cardSort==='matches'){ A=a.matches; B=b.matches; }
    else if (cardSort==='wins'){ A=a.wins; B=b.wins; }
    else if (cardSort==='winpct'){ A=a.matches ? a.wins/a.matches : -1; B=b.matches ? b.wins/b.matches : -1; }
    else if (cardSort==='subjectAppear'){ A=a._subj.appear; B=b._subj.appear; }
    else if (cardSort==='subjectRate'){ A=a._subj.rate; B=b._subj.rate; }
    else { A=a._subj.winrate; B=b._subj.winrate; }
    if (A<B) return cardDir==='asc' ? -1 : 1;
    if (A>B) return cardDir==='asc' ? 1 : -1;
    const nA=a.name?.toLowerCase()||'', nB=b.name?.toLowerCase()||'';
    if (nA<nB) return -1; if (nA>nB) return 1; return 0;
  };
  ordered.sort(cardCmp);

  const cards = [];
  ordered.forEach(b => {
    let skills = [...b.skills.entries()].map(([name, s]) => {
      const appearRate = b.matches ? (s.appear / b.matches) : 0;
      const winRate    = s.appear ? (s.appearWins / s.appear) : 0;
      return { name, ...s, appearRate, winRate };
    });

    const skillCmp = (x,y) => {
      let A,B;
      if (skillSort==='name'){ A=x.name.toLowerCase(); B=y.name.toLowerCase(); }
      else if (skillSort==='count'){ A=x.occ; B=y.occ; }
      else if (skillSort==='winrate'){ A=x.winRate; B=y.winRate; }
      else { A=x.appearRate; B=y.appearRate; }
      if (A<B) return skillDir==='asc' ? -1 : 1;
      if (A>B) return skillDir==='asc' ? 1 : -1;
      if (x.name.toLowerCase()<y.name.toLowerCase()) return -1;
      if (x.name.toLowerCase()>y.name.toLowerCase()) return 1;
      return 0;
    };
    skills.sort(skillCmp);

    const table = skills.length
      ? `<table class="sum-table">
           <thead><tr><th>Skill</th><th class="right">Count</th><th class="right">\${(kind==='ban')?'Ban Rate':'Pick Rate'}</th><th class="right">Win Rate</th></tr></thead>
           <tbody>
             \${skills.map(s => `
               <tr>
                 <td>\${s.name}</td>
                 <td class="right">\${s.occ}</td>
                 <td class="right">\${pct(s.appear,b.matches)}</td>
                 <td class="right">\${pct(s.appearWins,s.appear)}</td>
               </tr>`).join('')}
           </tbody>
         </table>`
      : `<div class="muted">No \${kind} data.</div>`;

    cards.push(`
      <div class="card">
        <h3>\${b.name}</h3>
        <div class="kpis">
          <div class="kpi">Matches <strong>\${b.matches}</strong></div>
          <div class="kpi">Wins <strong>\${b.wins}</strong> <span class="muted">(\${pct(b.wins,b.matches)})</span></div>
          <div class="kpi">\${(kind==='ban'?'Bans':'Picks')} <strong>\${b._subj.appear}</strong> <span class="muted">(\${pct(b._subj.appear,b.matches)})</span></div>
          <div class="kpi">When Appeared: <strong>\${pct(b._subj.appearWins,b._subj.appear)}</strong></div>
        </div>
        \${table}
      </div>
    `);
  });

  grid.innerHTML = cards.join('');
}

/* ========= Team × Map Win Rate ========= */
function renderTeamMapWinRate(){
  const sortBy = el('tmSort').value;
  const dir = el('tmDir').value;

  // Aggregate using RAW_RECORDS (already filtered by date/map/team/tournament)
  const agg = new Map(); // key = team||map -> {team,map,matches,wins}
  RAW_RECORDS.forEach(r=>{
    const l = r.team_left, rt = r.team_right;
    const lm = r.map, rm = r.map; // same map field
    const ls = r.team_left_score ?? 0, rs = r.team_right_score ?? 0;

    const k1 = l+'||'+lm;
    const k2 = rt+'||'+rm;
    if (!agg.has(k1)) agg.set(k1,{team:l,map:lm,matches:0,wins:0});
    if (!agg.has(k2)) agg.set(k2,{team:rt,map:rm,matches:0,wins:0});
    agg.get(k1).matches += 1;
    agg.get(k2).matches += 1;
    if (ls>rs) agg.get(k1).wins += 1;
    if (rs>ls) agg.get(k2).wins += 1;
  });

  const rows = [...agg.values()].map(x => ({...x, winpct: x.matches? x.wins/x.matches : 0}));

  const cmp = (a,b)=>{
    const s = (dir==='asc')?1:-1;
    const N = v => (v??0);
    if (sortBy==='winpct') return s*(a.winpct - b.winpct);
    if (sortBy==='wins')   return s*(a.wins - b.wins);
    if (sortBy==='matches')return s*(a.matches - b.matches);
    if (sortBy==='team')   return s*a.team.localeCompare(b.team);
    if (sortBy==='map')    return s*a.map.localeCompare(b.map);
    return 0;
  };
  rows.sort(cmp);

  const tbody = el('tmBody'); tbody.innerHTML='';
  rows.forEach(r=>{
    const tr=document.createElement('tr');
    tr.innerHTML = `
      <td>${r.team}</td>
      <td>${r.map}</td>
      <td class="mono">${r.matches}</td>
      <td class="mono">${r.wins}</td>
      <td class="mono">${fmtPct(r.winpct)}</td>
    `;
    tbody.appendChild(tr);
  });
  el('tmMeta').textContent = `${rows.length} team×map rows • From filters above`;
}

['tmSort','tmDir'].forEach(id=>{
  el(id).addEventListener('change', ()=> renderTeamMapWinRate());
});

/* ========= Skills Summary by Map ========= */
function renderSkillsByMap(){
  const mapSel = el('fMap').value;
  const rows = CURRENT_ROWS; // rows at team-side granularity (already filtered by team/WL)
  const maps = (mapSel==='__ALL__') ? uniq(rows.map(r=>r.map)) : [mapSel];

  const groupBy = el('ssGroupBy').value;
  const kind    = el('ssKind').value;
  const cardSort  = el('ssCardSort').value;
  const cardDir   = el('ssCardDir').value;
  const skillSort = el('ssSkillSort').value;
  const skillDir  = el('ssSkillDir').value;

  el('ssMeta').textContent = `${maps.length} map(s) • Using current filters`;

  const container = el('ssWrap');
  container.innerHTML='';

  // Helper to render a single map grid using same renderer as global summary
  function renderMapGrid(mapName, targetEl){
    const mapRows = rows.filter(r=>r.map===mapName);
    const buckets = buildBucketsFromRows(mapRows, groupBy, kind);

    // temporarily patch selects used by renderSummary
    const bak = {
      sumCardSort: el('sumCardSort').value,
      sumCardDir:  el('sumCardDir').value,
      sumSkillSort:el('sumSkillSort').value,
      sumSkillDir: el('sumSkillDir').value
    };
    el('sumCardSort').value  = cardSort;
    el('sumCardDir').value   = cardDir;
    el('sumSkillSort').value = skillSort;
    el('sumSkillDir').value  = skillDir;

    // render into an offscreen grid then move
    const tempGrid = document.createElement('div');
    tempGrid.className='grid';
    // Hijack renderSummary to use CURRENT_ROWS; temporarily swap CURRENT_ROWS
    const bakRows = CURRENT_ROWS;
    CURRENT_ROWS = mapRows;
    const bakGrid = el('sumGrid');
    const placeholder = document.createElement('div');
    placeholder.id = '___tmp_placeholder';
    bakGrid.parentNode.insertBefore(placeholder, bakGrid);
    bakGrid.replaceWith(tempGrid);
    renderSummary(buckets, groupBy, kind);
    // After renderSummary, tempGrid contains cards; attach to targetEl
    targetEl.appendChild(tempGrid);
    // Restore DOM and state
    tempGrid.replaceWith(bakGrid);
    placeholder.parentNode.removeChild(placeholder);
    CURRENT_ROWS = bakRows;
    el('sumCardSort').value  = bak.sumCardSort;
    el('sumCardDir').value   = bak.sumCardDir;
    el('sumSkillSort').value = bak.sumSkillSort;
    el('sumSkillDir').value  = bak.sumSkillDir;
  }

  if (mapSel==='__ALL__'){
    // Use accordions per map
    maps.sort().forEach(m=>{
      const details = document.createElement('details');
      details.className = 'card';
      const summary = document.createElement('summary');
      summary.style.cursor='pointer';
      summary.style.fontWeight='700';
      summary.style.color='var(--brand2)';
      summary.textContent = m;
      details.appendChild(summary);

      const inner = document.createElement('div');
      inner.style.marginTop='10px';
      details.appendChild(inner);
      container.appendChild(details);

      // Lazy render on open
      details.addEventListener('toggle', ()=>{
        if (details.open && !inner.hasChildNodes()){
          renderMapGrid(m, inner);
        }
      }, { once:true });
    });
  } else {
    // Single map view, render immediately
    const inner = document.createElement('div');
    container.appendChild(inner);
    renderMapGrid(maps[0], inner);
  }
}

['ssGroupBy','ssKind','ssCardSort','ssCardDir','ssSkillSort','ssSkillDir'].forEach(id=>{
  el(id).addEventListener('change', ()=> renderSkillsByMap());
});

/* ========= Tabs behavior (lazy render heavy sections) ========= */
const TAB_TO_SECTION = {
  match: 'sec-match',
  summary: 'sec-summary',
  teammap: 'sec-teammap',
  skillsbymap: 'sec-skillsbymap',
  perskill: 'sec-perskill'
};
document.querySelectorAll('.tab').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    const target = TAB_TO_SECTION[btn.dataset.tab];
    document.querySelectorAll('.js-section').forEach(s=>s.classList.remove('active'));
    document.getElementById(target)?.classList.add('active');

    // Lazy compute
    if (target==='sec-match')       { PAGE=1; renderRowsPaged(CURRENT_ROWS); }
    if (target==='sec-summary')     { const b=buildBucketsFromRows(CURRENT_ROWS, el('sumGroupBy').value, el('sumKind').value); renderSummary(b, el('sumGroupBy').value, el('sumKind').value); }
    if (target==='sec-teammap')     { renderTeamMapWinRate(); }
    if (target==='sec-skillsbymap') { renderSkillsByMap(); }
    if (target==='sec-perskill')    { computeSkillStats(); }
  });
});

/* ========= Main refresh ========= */
async function refresh(){
  RAW_RECORDS = await fetchRecords();
  populateTeamDropdown(RAW_RECORDS);
  populateTournamentDropdown(RAW_RECORDS);

  const teamSel  = el('fTeam').value || '__ALL__';
  const tournSel = el('fTourn').value || '__ALL__';
  el('filterMeta').textContent =
    `Loaded ${RAW_RECORDS.length} matches • Team: ${teamSel==='__ALL__'?'All teams':teamSel} • Map: ${el('fMap').value} • Tournament: ${tournSel==='__ALL__'?'All':tournSel}`;

  const exploded = RAW_RECORDS.flatMap(explodeRecordToRows);
  CURRENT_ROWS = applyRowFilters(exploded);

  // Render only the active section
  const active = document.querySelector('.js-section.active')?.id || 'sec-match';
  if (active==='sec-match'){ PAGE = 1; renderRowsPaged(CURRENT_ROWS); }
  if (active==='sec-summary'){
    const buckets = buildBucketsFromRows(CURRENT_ROWS, el('sumGroupBy').value, el('sumKind').value);
    renderSummary(buckets, el('sumGroupBy').value, el('sumKind').value);
  }
  if (active==='sec-teammap'){ renderTeamMapWinRate(); }
  if (active==='sec-skillsbymap'){ renderSkillsByMap(); }
  if (active==='sec-perskill'){ computeSkillStats(); }
}

/* ========= Events ========= */
el('applyBtn').onclick = refresh;
['sumGroupBy','sumKind','sumCardSort','sumCardDir','sumSkillSort','sumSkillDir'].forEach(id=>{
  el(id).addEventListener('change', () => {
    if (!document.getElementById('sec-summary').classList.contains('active')) return;
    const buckets = buildBucketsFromRows(CURRENT_ROWS, el('sumGroupBy').value, el('sumKind').value);
    renderSummary(buckets, el('sumGroupBy').value, el('sumKind').value);
  });
});

/* ========= First load ========= */
refresh();

/* ===== Per-Skill Stats (Active/Passive) ===== */
async function computeSkillStats() {
  const type  = document.getElementById('skillTypeSelect').value;
  const team  = (document.getElementById('fTeam').value || '__ALL__');
  const from  = document.getElementById('fFrom').value;
  const to    = document.getElementById('fTo').value;
  const tourn = (document.getElementById('fTourn').value || '__ALL__');

  if (!from || !to) {
    alert('Please set a From and To date for Skill Stats.');
    return;
  }

  let q = client
    .from('draft_records')
    .select('team_left, team_right, team_left_score, team_right_score, match_date, map, tournament_name, state')
    .gte('match_date', from)
    .lte('match_date', to);

  if (team !== '__ALL__')  q = q.or(`team_left.eq.${team},team_right.eq.${team}`);
  if (tourn !== '__ALL__') q = q.eq('tournament_name', tourn);

  const { data, error } = await q;
  if (error) {
    console.error('❌ Skill stats fetch error:', error);
    alert('Failed to fetch records for Skill Stats.');
    return;
  }

  const sidesPerMatch = (team === '__ALL__') ? 2 : 1;
  const activeSlotsPerMatch  = 4 * sidesPerMatch;
  const passiveSlotsPerMatch = 12 * sidesPerMatch;
  const banSlotsPerMatch     = 1 * sidesPerMatch;

  const matches = data.length;

  const pickDen = (type === 'active') ? (matches * activeSlotsPerMatch)
                                      : (matches * passiveSlotsPerMatch);
  const banDen  = (type === 'active') ? (matches * banSlotsPerMatch) : 0;

  const skills = new Map(); // name -> {name,img,picks,bans,wins}
  const addSkill = (name, img) => {
    if (!name) return null;
    if (!skills.has(name)) skills.set(name, { name, img: img || PLACEHOLDER, picks: 0, bans: 0, wins: 0 });
    return skills.get(name);
  };
  const forSide = (r, side, fn) => {
    if (team !== '__ALL__') {
      const sideTeam = (side === 'L') ? r.team_left : r.team_right;
      if (sideTeam !== team) return;
    }
    fn();
  };

  data.forEach(r => {
    const s = r.state || {};
    const picks = s.picks || [];
    const bans  = s.bans  || [];
    const pass  = s.passives || [];

    const lScore = r.team_left_score ?? 0;
    const rScore = r.team_right_score ?? 0;
    const lWin = lScore > rScore;
    const rWin = rScore > lScore;

    if (type === 'active') {
      forSide(r, 'L', () => {
        [0,1,2,3].forEach(i => {
          const hero = picks[i];
          if (!hero || !hero.name) return;
          const sk = addSkill(hero.name, hero.image_url);
          if (!sk) return;
          sk.picks += 1;
          if (lWin) sk.wins += 1;
        });
        const ban = bans[0];
        if (ban && ban.name) {
          const sk = addSkill(ban.name, ban.image_url);
          if (sk) sk.bans += 1;
        }
      });

      forSide(r, 'R', () => {
        [4,5,6,7].forEach(i => {
          const hero = picks[i];
          if (!hero || !hero.name) return;
          const sk = addSkill(hero.name, hero.image_url);
          if (!sk) return;
          sk.picks += 1;
          if (rWin) sk.wins += 1;
        });
        const ban = bans[1];
        if (ban && ban.name) {
          const sk = addSkill(ban.name, ban.image_url);
          if (sk) sk.bans += 1;
        }
      });
    } else {
      forSide(r, 'L', () => {
        [0,1,2,3].forEach(i => {
          const trio = pass[i] || [];
          trio.forEach(ps => {
            if (!ps || !ps.name) return;
            const sk = addSkill(ps.name, ps.image_url);
            if (!sk) return;
            sk.picks += 1;
            if (lWin) sk.wins += 1;
          });
        });
      });
      forSide(r, 'R', () => {
        [4,5,6,7].forEach(i => {
          const trio = pass[i] || [];
          trio.forEach(ps => {
            if (!ps || !ps.name) return;
            const sk = addSkill(ps.name, ps.image_url);
            if (!sk) return;
            sk.picks += 1;
            if (rWin) sk.wins += 1;
          });
        });
      });
    }
  });

  const rows = Array.from(skills.values()).map(sk => {
    const pickRate = pickDen ? (sk.picks / pickDen) : 0;
    const banRate  = (type === 'active' && banDen) ? (sk.bans / banDen) : null;
    const winRate  = sk.picks ? (sk.wins / sk.picks) : null;
    return { ...sk, pickRate, banRate, winRate };
  });

  const sortBy = document.getElementById('skillSortBy').value;
  const dir    = document.getElementById('skillSortDir').value;
  const cmp = (a, b) => {
    const sign = (dir === 'asc') ? 1 : -1;
    const num = k => (isNaN(k) || k === null) ? -Infinity : +k;
    switch (sortBy) {
      case 'name':    return sign * a.name.localeCompare(b.name);
      case 'picks':   return sign * (a.picks - b.picks);
      case 'pickRate':return sign * (num(a.pickRate) - num(b.pickRate));
      case 'bans':    return sign * (a.bans - b.bans);
      case 'banRate': return sign * (num(a.banRate) - num(b.banRate));
      case 'wins':    return sign * (a.wins - b.wins);
      case 'winRate': return sign * (num(a.winRate) - num(b.winRate));
      default:        return 0;
    }
  };
  rows.sort(cmp);

  const tbody = document.getElementById('skillStatsBody');
  tbody.innerHTML = '';
  rows.forEach(r => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>
        <div class="skill-cell">
          <img src="${r.img || PLACEHOLDER}" alt="${r.name}" loading="lazy">
          <span class="skill-name">${r.name}</span>
        </div>
      </td>
      <td class="mono">${r.picks}</td>
      <td class="mono">${pct(r.picks, pickDen)}</td>
      <td class="mono">${(type === 'active') ? r.bans : '—'}</td>
      <td class="mono">${(type === 'active') ? pct(r.bans, banDen) : '—'}</td>
      <td class="mono">${r.wins}</td>
      <td class="mono">${(r.winRate === null) ? '—' : (r.winRate * 100).toFixed(1) + '%'}</td>
    `;
    tbody.appendChild(tr);
  });

  const teamLabel  = (team === '__ALL__') ? 'All teams' : team;
  const typeLabel  = (type === 'active') ? 'Active' : 'Passive';
  const tournLabel = (tourn === '__ALL__') ? 'All tournaments' : tourn;
  document.getElementById('skillStatsMeta').textContent =
    `${teamLabel} • ${tournLabel} • ${typeLabel} • Matches: ${matches} • Slots: ` +
    `${(type==='active') ? pickDen + ' active' : pickDen + ' passive'}` +
    `${(type==='active') ? ` • Ban slots: ${banDen}` : ''}`;
}
['skillTypeSelect','skillSortBy','skillSortDir'].forEach(id=>{
  const node = document.getElementById(id);
  if (node) node.addEventListener('change', () => computeSkillStats());
});
</script>
</body>
</html>
