<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Clash Squad — Skills Report</title>

  <!-- Supabase JS v2 (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    :root{
      --bg:#070709;
      --panel:#111114;
      --panel2:#0d0d10;
      --ink:#f5f5f7;
      --muted:#b6b6bc;
      --brand:#ffbd59;
      --brand2:#ff7733;
      --line:rgba(255,255,255,.10);
      --stroke:rgba(255,255,255,.08);
      --shadow:0 18px 60px rgba(0,0,0,.55);
      --radius:14px;
      --radius-lg:18px;
      --good:#71d083;
      --bad:#ff6b6b;

      /* Sleek glass vibe */
      --glass:rgba(25,25,28,.58);
      --glass2:rgba(18,18,20,.68);
      --glow:0 0 0 1px rgba(255,189,89,.14), 0 18px 48px rgba(0,0,0,.55);
      --glow2:0 0 0 1px rgba(255,119,51,.12), 0 18px 48px rgba(0,0,0,.55);
      --blur:12px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
      background:
        radial-gradient(1200px 700px at 20% -10%, rgba(255,189,89,.18), transparent 55%),
        radial-gradient(1000px 600px at 90% 0%, rgba(255,119,51,.16), transparent 52%),
        radial-gradient(900px 600px at 50% 120%, rgba(120,150,255,.08), transparent 55%),
        linear-gradient(180deg, #050507, #0a0a0d 45%, #050507 100%);
      overflow-x:hidden;
    }

    a{color:inherit}
    .wrap{
      max-width:1200px;
      margin:0 auto;
      padding:14px 14px 80px;
    }

    /* Top bar */
    .topbar{
      position:sticky;
      top:0;
      z-index:50;
      backdrop-filter: blur(var(--blur));
      background:linear-gradient(180deg, rgba(8,8,10,.92), rgba(8,8,10,.65));
      border-bottom:1px solid var(--line);
    }
    .topbar-inner{
      max-width:1200px;
      margin:0 auto;
      padding:12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    .logo{
      width:34px;height:34px;border-radius:10px;
      background:
        radial-gradient(circle at 30% 30%, rgba(255,189,89,.85), rgba(255,119,51,.35) 60%, rgba(0,0,0,0) 61%),
        linear-gradient(135deg, rgba(255,189,89,.18), rgba(255,119,51,.10));
      box-shadow:0 0 0 1px rgba(255,189,89,.22), 0 14px 26px rgba(0,0,0,.55);
    }
    .titleblock{min-width:0}
    .title{
      font-weight:900;
      letter-spacing:.2px;
      font-size:1.02rem;
      line-height:1.1;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .subtitle{
      font-size:.82rem;
      color:var(--muted);
      margin-top:3px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .top-actions{display:flex; align-items:center; gap:10px}
    .btn{
      appearance:none;
      border:none;
      cursor:pointer;
      padding:10px 12px;
      border-radius:12px;
      color:var(--ink);
      background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      box-shadow:0 0 0 1px rgba(255,255,255,.10);
      font-weight:800;
      font-size:.86rem;
      transition:transform .12s ease, box-shadow .12s ease, background .12s ease;
      user-select:none;
    }
    .btn:hover{transform:translateY(-1px); box-shadow:0 0 0 1px rgba(255,255,255,.14), 0 16px 36px rgba(0,0,0,.55)}
    .btn:active{transform:translateY(0px)}
    .btn.primary{
      background:linear-gradient(180deg, rgba(255,189,89,.22), rgba(255,119,51,.12));
      box-shadow:0 0 0 1px rgba(255,189,89,.20), 0 18px 46px rgba(0,0,0,.58);
    }

    /* Tabs */
    .tabs{
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px 0 0;
      flex-wrap:wrap;
    }
    .tab{
      padding:10px 14px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      color:var(--muted);
      font-weight:900;
      font-size:.88rem;
      cursor:pointer;
      transition:.12s ease;
      user-select:none;
    }
    .tab:hover{color:var(--ink); border-color:rgba(255,255,255,.16)}
    .tab.active{
      color:#1b1204;
      border-color:rgba(255,189,89,.35);
      background:linear-gradient(180deg, rgba(255,189,89,.95), rgba(255,170,80,.85));
      box-shadow:0 10px 26px rgba(0,0,0,.45);
    }

    /* Controls panel */
    .panel{
      margin-top:14px;
      background:linear-gradient(180deg, var(--glass), rgba(15,15,18,.55));
      border:1px solid var(--stroke);
      border-radius:var(--radius-lg);
      box-shadow:var(--shadow);
      backdrop-filter: blur(var(--blur));
      padding:14px;
    }
    .controls{
      display:grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap:10px;
      align-items:end;
    }
    .controls .field{min-width:0}
    label{
      display:block;
      font-size:.72rem;
      color:var(--muted);
      letter-spacing:.3px;
      margin:0 0 6px 2px;
      text-transform:uppercase;
      font-weight:800;
    }

    input[type="date"], select{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(10,10,12,.72);
      color:var(--ink);
      outline:none;
      font-weight:800;
      font-size:.90rem;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }

    /* Fix: dropdown options turning white/light */
    select option{
      background:#0b0b0f;
      color:#f5f5f7;
    }

    input[type="date"]::-webkit-calendar-picker-indicator{filter:invert(1) opacity(.8)}

    .controls .actions{
      display:flex;
      gap:10px;
      justify-content:flex-end;
      grid-column: span 2;
    }

    .note{
      margin-top:10px;
      color:var(--muted);
      font-size:.86rem;
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .pillrow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
      color:var(--muted);
      font-size:.82rem;
      font-weight:800;
      white-space:nowrap;
    }
    .dot{
      width:8px;height:8px;border-radius:99px;background:rgba(255,189,89,.85);
      box-shadow:0 0 0 3px rgba(255,189,89,.18);
    }

    /* Content blocks */
    .grid{
      margin-top:14px;
      display:grid;
      grid-template-columns:repeat(3, minmax(0, 1fr));
      gap:14px;
      align-items:start;
    }
    .block{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--stroke);
      border-radius:var(--radius-lg);
      box-shadow:var(--shadow);
      padding:14px;
      min-height:120px;
      backdrop-filter: blur(var(--blur));
    }
    .block h3{
      margin:0 0 10px;
      font-size:.98rem;
      letter-spacing:.2px;
    }
    .muted{color:var(--muted)}
    .mono{font-variant-numeric: tabular-nums}
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
      font-weight:900;
      font-size:.80rem;
      color:var(--muted);
      white-space:nowrap;
    }

    /* Match list */
    .match{
      background:linear-gradient(180deg, rgba(0,0,0,.22), rgba(0,0,0,.10));
      border:1px solid rgba(255,255,255,.08);
      border-radius:16px;
      padding:12px;
      margin-top:10px;
    }
    .matchHead{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    .matchTitle{
      font-weight:1000;
      letter-spacing:.2px;
    }
    .matchMeta{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }

    .row{
      display:grid;
      grid-template-columns: 1.1fr 1.1fr 1fr;
      gap:12px;
      align-items:start;
    }
    .teamBox{
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      background:rgba(255,255,255,.03);
      padding:10px;
      min-height:92px;
    }
    .teamName{
      font-weight:1000;
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      gap:8px;
      margin-bottom:8px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .teamName .miniDot{width:8px;height:8px;border-radius:99px;background:rgba(255,119,51,.75)}
    .playersWrap{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .player{
      display:flex;
      gap:10px;
      align-items:flex-start;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(0,0,0,.18);
    }
    .pInfo{
      flex:1;
      min-width:0;
    }
    .pName{
      font-weight:900;
      font-size:.88rem;
      line-height:1.15;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      margin-bottom:2px;
    }
    .pHero{
      font-size:.80rem;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .pActs{
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .pAct{
      width:30px;height:30px;border-radius:8px;
      object-fit:cover;
      box-shadow:0 0 0 1px rgba(255,255,255,.10);
      background:#111;
    }

    /* Passive icons line */
    .pPass{
      margin-top:6px;
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      align-items:center;
    }
    .pPassItem{
      display:flex;
      gap:6px;
      align-items:center;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(0,0,0,.14);
      padding:5px 8px;
      border-radius:999px;
      max-width:100%;
    }
    .pPassItem img{
      width:18px;height:18px;border-radius:6px;object-fit:cover;
      box-shadow:0 0 0 1px rgba(255,255,255,.08);
      background:#111;
      flex:0 0 auto;
    }
    .pPassItem span{
      font-size:.78rem;
      color:var(--muted);
      font-weight:800;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width:200px;
    }

    /* Bans box */
    .bansBox{
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      background:rgba(255,255,255,.03);
      padding:10px;
      min-height:92px;
    }
    .bansGrid{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      margin-top:8px;
    }
    .banCell{
      display:flex;
      gap:8px;
      align-items:center;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(0,0,0,.18);
      padding:7px 10px;
      border-radius:12px;
      max-width:100%;
    }
    .banCell img{
      width:30px;height:30px;border-radius:8px;object-fit:cover;
      box-shadow:0 0 0 1px rgba(255,255,255,.10);
      background:#111;
      flex:0 0 auto;
    }
    .banCell .bn{
      font-weight:900;
      font-size:.86rem;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width:180px;
    }
    .banCell .bt{
      font-size:.74rem;color:var(--muted);font-weight:800;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width:220px;
    }

    /* Summary cards */
    .cardsGrid{
      display:grid;
      grid-template-columns:repeat(3, minmax(0, 1fr));
      gap:14px;
      margin-top:14px;
      align-items:start;
    }
    .card{background:var(--panel2);border:1px solid var(--stroke);border-radius:16px;padding:12px;box-shadow:var(--shadow);min-width:0;overflow:hidden}
    .card h4{
      margin:0 0 8px;
      font-size:.95rem;
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .kpis{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:7px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
      font-weight:900;
      font-size:.80rem;
      color:var(--muted);
      white-space:nowrap;
    }

    .sum-table{
      width:100%;
      border-collapse:collapse;
      font-size:.92rem;
      table-layout:fixed;
    }
    .sum-table thead th{
      text-align:left;
      color:var(--muted);
      font-weight:900;
      font-size:.76rem;
      letter-spacing:.3px;
      text-transform:uppercase;
      padding:10px 8px;
      border-bottom:1px solid rgba(255,255,255,.08);
      background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    }
    .sum-table th,.sum-table td{
      padding:10px 8px;
      border-bottom:1px solid rgba(255,255,255,.06);
      vertical-align:middle;
    }

    /* Prevent table overflow inside cards */
    .tableWrap{max-width:100%;overflow:auto;-webkit-overflow-scrolling:touch;border-radius:12px}
    .tableWrap table{width:100%}
    .card .sum-table th:first-child,.card .sum-table td:first-child{white-space:normal;overflow-wrap:anywhere}
    .card .sum-table th:not(:first-child),.card .sum-table td:not(:first-child){white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

    .sum-table tbody tr:hover{background:rgba(255,255,255,.03)}
    .right{text-align:right}
    .good{color:var(--good);font-weight:1000}
    .bad{color:var(--bad);font-weight:1000}

    /* Skill cell includes icon + name */
    .skill-cell{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    .skill-cell img{
      width:30px;height:30px;border-radius:8px;object-fit:cover;
      box-shadow:0 0 0 1px rgba(255,255,255,.10);
      background:#111;
      flex:0 0 auto;
    }
    .skill-name{
      font-weight:950;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      min-width:0;
    }

    /* Team × Map view */
    .twoCol{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
      margin-top:14px;
    }
    .section{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--stroke);
      border-radius:var(--radius-lg);
      box-shadow:var(--shadow);
      padding:14px;
      backdrop-filter: blur(var(--blur));
    }
    .section h3{
      margin:0 0 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    /* Tooltip for skill details (from character.json) */
    .tt{
      position:fixed;
      z-index:9999;
      max-width:min(420px, calc(100vw - 24px));
      pointer-events:none;
      transform:translate3d(-9999px,-9999px,0);
      opacity:0;
      transition:opacity .08s ease;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background:linear-gradient(180deg, rgba(18,18,22,.96), rgba(10,10,12,.94));
      box-shadow:0 22px 60px rgba(0,0,0,.7);
      backdrop-filter: blur(10px);
    }
    .tt.show{opacity:1}
    .tt .tt-top{
      display:flex;
      gap:10px;
      align-items:center;
      margin-bottom:8px;
      min-width:0;
    }
    .tt .tt-top img{
      width:42px;height:42px;border-radius:12px;object-fit:cover;
      box-shadow:0 0 0 1px rgba(255,255,255,.12);
      background:#111;
      flex:0 0 auto;
    }
    .tt .tt-titles{min-width:0}
    .tt .tt-name{
      font-weight:1000;
      letter-spacing:.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .tt .tt-skill{
      margin-top:2px;
      font-size:.82rem;
      color:rgba(255,189,89,.95);
      font-weight:900;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .tt .tt-desc{
      color:var(--muted);
      font-size:.86rem;
      line-height:1.25;
      margin:0;
      white-space:normal;
      overflow-wrap:anywhere;
    }
    .tt .tt-meta{
      margin-top:8px;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .tt .tt-pill{
      font-size:.72rem;
      font-weight:900;
      color:var(--muted);
      padding:5px 8px;
      border:1px solid rgba(255,255,255,.10);
      border-radius:999px;
      background:rgba(255,255,255,.04);
      white-space:nowrap;
    }

    /* Responsive */
    @media (max-width: 1024px){
      .controls{grid-template-columns: repeat(3, minmax(0,1fr));}
      .controls .actions{grid-column: span 3; justify-content:flex-start}
      .grid{grid-template-columns:1fr}
      .cardsGrid{grid-template-columns:1fr}
      .row{grid-template-columns:1fr}
      .twoCol{grid-template-columns:1fr}
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div class="titleblock">
          <div class="title">Clash Squad — Skills Report</div>
          <div class="subtitle" id="subline">Picks, bans, and performance by active/passive skills</div>
        </div>
      </div>
      <div class="top-actions">
        <button class="btn" id="btnRefresh">Refresh</button>
        <button class="btn primary" id="btnExport">Export CSV</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="tabs" role="tablist" aria-label="Views">
      <div class="tab active" data-tab="matches" role="tab" aria-selected="true">Matches</div>
      <div class="tab" data-tab="summary" role="tab" aria-selected="false">Summary</div>
      <div class="tab" data-tab="teammap" role="tab" aria-selected="false">Team × Map</div>
    </div>

    <div class="panel">
      <div class="controls">
        <div class="field">
          <label for="fFrom">From</label>
          <input type="date" id="fFrom"/>
        </div>
        <div class="field">
          <label for="fTo">To</label>
          <input type="date" id="fTo"/>
        </div>
        <div class="field">
          <label for="fTourn">Tournament</label>
          <select id="fTourn"></select>
        </div>
        <div class="field">
          <label for="fMap">Map</label>
          <select id="fMap"></select>
        </div>
        <div class="field">
          <label for="fTeam">Team</label>
          <select id="fTeam"></select>
        </div>
        <div class="actions">
          <button class="btn" id="btnApply">Apply</button>
          <button class="btn" id="btnReset">Reset</button>
        </div>
      </div>

      <div class="note">
        <div class="pillrow" id="scopePills">
          <span class="pill"><span class="dot"></span><span class="mono" id="pillMatches">Loaded 0 matches</span></span>
          <span class="pill"><span class="mono" id="pillTeam">Team: All teams</span></span>
          <span class="pill"><span class="mono" id="pillMap">Map: All maps</span></span>
          <span class="pill"><span class="mono" id="pillTourn">Tournament: —</span></span>
        </div>
        <div class="pillrow">
          <span class="badge mono" id="lastSync">Last sync: —</span>
        </div>
      </div>
    </div>

    <!-- Matches view -->
    <div id="viewMatches">
      <div class="grid">
        <div class="block">
          <h3>Quick KPIs</h3>
          <div class="pillrow" id="kpiRow"></div>
          <div class="muted" style="margin-top:8px">KPIs computed from filtered matches.</div>
        </div>

        <div class="block">
          <h3>Top Active Picks</h3>
          <div id="topActive" class="muted">—</div>
        </div>

        <div class="block">
          <h3>Top Passive Picks</h3>
          <div id="topPassive" class="muted">—</div>
        </div>
      </div>

      <div class="section" style="margin-top:14px">
        <h3>Match List <span class="muted" id="matchCount">0</span></h3>
        <div id="matchList" class="muted">Loading…</div>
      </div>
    </div>

    <!-- Summary view -->
    <div id="viewSummary" style="display:none">
      <div class="panel" style="margin-top:14px">
        <div class="controls" style="grid-template-columns: repeat(4, minmax(0,1fr));">
          <div class="field">
            <label for="sumGroup">Group by</label>
            <select id="sumGroup">
              <option value="team">Team</option>
              <option value="map">Map</option>
              <option value="tournament">Tournament</option>
            </select>
          </div>
          <div class="field">
            <label for="sumSubject">Subject</label>
            <select id="sumSubject">
              <option value="active">Active skills</option>
              <option value="passive">Passive skills</option>
              <option value="bans">Banned skills</option>
            </select>
          </div>
          <div class="field">
            <label for="sumMin">Min count</label>
            <select id="sumMin">
              <option value="1">1+</option>
              <option value="2">2+</option>
              <option value="3">3+</option>
              <option value="5">5+</option>
              <option value="8">8+</option>
            </select>
          </div>
          <div class="actions" style="grid-column: span 1; justify-content:flex-end">
            <button class="btn primary" id="btnRecalc">Recalculate</button>
          </div>
        </div>

        <div class="note">
          <div class="muted mono" id="sumMeta">—</div>
        </div>
      </div>

      <div class="cardsGrid" id="summaryCards"></div>
    </div>

    <!-- Team × Map view -->
    <div id="viewTeamMap" style="display:none">
      <div class="twoCol">
        <div class="section">
          <h3>Skill Performance by Map <span class="muted" id="tmMeta1">—</span></h3>
          <div class="muted" style="margin-bottom:10px">
            Tracks how often a skill appears and its win rate on each map.
          </div>
          <div id="tmTable1" class="muted">—</div>
        </div>

        <div class="section">
          <h3>Ban Impact <span class="muted" id="tmMeta2">—</span></h3>
          <div class="muted" style="margin-bottom:10px">
            When a skill is banned, how does the banning team perform?
          </div>
          <div id="tmTable2" class="muted">—</div>
        </div>
      </div>

      <div class="section" style="margin-top:14px">
        <h3>Combos & Pairings <span class="muted" id="tmMeta3">—</span></h3>
        <div class="muted" style="margin-bottom:10px">
          Most common pairs of actives across the same player, and team-wide combos per match.
        </div>
        <div id="tmTable3" class="muted">—</div>
      </div>

      <div class="section" style="margin-top:14px">
        <h3>Passive Skill Bundles <span class="muted" id="tmMeta4">—</span></h3>
        <div class="muted" style="margin-bottom:10px">
          Passive sets used by players, and which bundles correlate with wins.
        </div>
        <div id="tmTable4" class="muted">—</div>
      </div>
    </div>
  </div>

  <!-- Tooltip element -->
  <div class="tt" id="tt">
    <div class="tt-top">
      <img id="ttImg" src="" alt="">
      <div class="tt-titles">
        <div class="tt-name" id="ttName">—</div>
        <div class="tt-skill" id="ttSkill">—</div>
      </div>
    </div>
    <p class="tt-desc" id="ttDesc">—</p>
    <div class="tt-meta" id="ttMeta"></div>
  </div>

<script>
/* ===========================
   CONFIG: Supabase + Tables
=========================== */
const SUPABASE_URL = 'https://gkugecflfddkpitlrmws.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdrdWdlY2ZsZmRka3BpdGxybXdzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDYwODMwNzQsImV4cCI6MjA2MTY1OTA3NH0.Oa8tBjsB2F41h6-ivH8kW1TWD8i3WQdACNf1vJt8Q0o';

const client = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

/**
 * Expected table structure (flexible): "clash_squad_skills" or similar
 * We'll default to "clash_squad_skills" and accept whatever columns exist in rows.
 * You can change this if your table name differs:
 */
const TABLE_NAME = 'clash_squad_skills';

/**
 * Character JSON (for tooltip skill name + description).
 * Update this path if your character.json is elsewhere.
 */
const CHARACTER_JSON_URL = './character.json';

/* ===========================
   STATE
=========================== */
let RAW_MATCHES = [];
let RAW_RECORDS = [];
let CHAR_INDEX = new Map(); // character name -> normalized info

const DEFAULTS = {
  map: '__ALL__',
  team: '__ALL__',
  tournament: '__ALL__',
};

function el(id){ return document.getElementById(id); }
function escapeHtml(s){
  return String(s ?? '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}
function fmtPct(x){
  if(!isFinite(x)) return '0.0%';
  return (x*100).toFixed(1)+'%';
}
function fmtNum(x){ return (Number(x)||0).toLocaleString(); }

function toISODate(d){
  const z = n => String(n).padStart(2,'0');
  return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}`;
}

/* ===========================
   CHARACTER.JSON -> Tooltip DB
=========================== */
function normName(s){ return String(s ?? '').trim(); }

function pick(obj, keys){
  for(const k of keys){
    if(obj && obj[k] != null && String(obj[k]).trim() !== '') return obj[k];
  }
  return '';
}

function normalizeCharacterRow(row){
  const name = normName(pick(row, ['name','character','hero','Character','Hero','Name']));
  if(!name) return null;

  const image = String(pick(row, ['image','img','portrait','icon','photo','Image','Img','Icon']) || '').trim();

  const skillName = String(pick(row, ['skill_name','skillName','skill','ability','SkillName','Skill','Ability','active_skill','activeSkill']) || '').trim();
  const skillDesc = String(pick(row, ['skill_desc','skillDesc','description','desc','SkillDesc','Description','Desc','skill_description','skillDescription']) || '').trim();

  const skillType = String(pick(row, ['skill_type','skillType','type','SkillType','Type']) || '').trim();
  const role = String(pick(row, ['role','Role']) || '').trim();

  const meta = String(pick(row, ['meta','cs_meta','br_meta','Meta','CS_META','BR_META']) || '').trim();

  return { name, image, skillName, skillDesc, skillType, role, meta };
}

async function loadCharacterJSON(){
  try{
    const res = await fetch(CHARACTER_JSON_URL, {cache:'no-store'});
    if(!res.ok) throw new Error('Failed to fetch character.json');
    const json = await res.json();
    const arr = Array.isArray(json) ? json : (json?.data && Array.isArray(json.data) ? json.data : []);
    const map = new Map();
    for(const row of arr){
      const n = normalizeCharacterRow(row);
      if(n && n.name){
        map.set(n.name.toLowerCase(), n);
      }
    }
    CHAR_INDEX = map;
  }catch(err){
    console.warn('Character JSON not loaded:', err);
    CHAR_INDEX = new Map();
  }
}

function getSkillInfo(characterName){
  const key = normName(characterName).toLowerCase();
  return CHAR_INDEX.get(key) || null;
}

/* ===========================
   TOOLTIP (delegated)
=========================== */
const tt = el('tt');
const ttImg = el('ttImg');
const ttName = el('ttName');
const ttSkill = el('ttSkill');
const ttDesc = el('ttDesc');
const ttMeta = el('ttMeta');

function isSkillNode(node){
  if(!node) return false;
  if(node.dataset && node.dataset.skill) return true;
  if(node.tagName === 'IMG'){
    // icons in these wrappers are usually skills
    return !!node.closest('.playersWrap, .skill-cell, .comboIcons, .icons, .banCell, .pPass');
  }
  return false;
}

function getSkillNameFromNode(node){
  if(node.dataset && node.dataset.skill) return node.dataset.skill;
  if(node.tagName === 'IMG'){
    return node.getAttribute('alt') || node.getAttribute('title') || '';
  }
  return '';
}

let ttVisible = false;

function showTT(skillName, x, y){
  const info = getSkillInfo(skillName);
  if(!info || (!info.skillName && !info.skillDesc)){
    hideTT();
    return;
  }

  ttName.textContent = info.name || skillName || '—';
  ttSkill.textContent = info.skillName || '—';
  ttDesc.textContent = info.skillDesc || '—';

  if(info.image){
    ttImg.src = info.image;
    ttImg.style.display = '';
  }else{
    ttImg.src = '';
    ttImg.style.display = 'none';
  }

  ttMeta.innerHTML = '';
  const pills = [];
  if(info.skillType) pills.push(info.skillType);
  if(info.role) pills.push(info.role);
  if(info.meta) pills.push(String(info.meta).toUpperCase());
  for(const p of pills){
    const div = document.createElement('div');
    div.className = 'tt-pill';
    div.textContent = p;
    ttMeta.appendChild(div);
  }

  // Position (clamped)
  const pad = 12;
  tt.classList.add('show');
  ttVisible = true;

  // First place offscreen so we can measure
  tt.style.transform = 'translate3d(-9999px,-9999px,0)';

  requestAnimationFrame(() => {
    const rect = tt.getBoundingClientRect();
    let nx = x + 14;
    let ny = y + 14;

    if(nx + rect.width + pad > window.innerWidth) nx = x - rect.width - 14;
    if(ny + rect.height + pad > window.innerHeight) ny = y - rect.height - 14;
    nx = Math.max(pad, Math.min(nx, window.innerWidth - rect.width - pad));
    ny = Math.max(pad, Math.min(ny, window.innerHeight - rect.height - pad));

    tt.style.transform = `translate3d(${nx}px, ${ny}px, 0)`;
  });
}

function hideTT(){
  if(!ttVisible) return;
  ttVisible = false;
  tt.classList.remove('show');
  tt.style.transform = 'translate3d(-9999px,-9999px,0)';
}

function bindSkillTooltipDelegation(){
  document.addEventListener('mousemove', (e) => {
    if(!ttVisible) return;
    // follow cursor smoothly
    const rect = tt.getBoundingClientRect();
    const pad = 12;
    let nx = e.clientX + 14;
    let ny = e.clientY + 14;
    if(nx + rect.width + pad > window.innerWidth) nx = e.clientX - rect.width - 14;
    if(ny + rect.height + pad > window.innerHeight) ny = e.clientY - rect.height - 14;
    nx = Math.max(pad, Math.min(nx, window.innerWidth - rect.width - pad));
    ny = Math.max(pad, Math.min(ny, window.innerHeight - rect.height - pad));
    tt.style.transform = `translate3d(${nx}px, ${ny}px, 0)`;
  });

  document.addEventListener('mouseover', (e) => {
    const t = e.target;
    if(!isSkillNode(t)) return;
    const name = getSkillNameFromNode(t);
    if(!name) return;
    showTT(name, e.clientX, e.clientY);
  }, true);

  document.addEventListener('mouseout', (e) => {
    const t = e.target;
    if(!isSkillNode(t)) return;
    hideTT();
  }, true);

  document.addEventListener('scroll', hideTT, true);
  window.addEventListener('blur', hideTT);
}

/* ===========================
   DATA FETCH
=========================== */
function getFilters(){
  return {
    from: el('fFrom').value,
    to: el('fTo').value,
    tournament: el('fTourn').value,
    map: el('fMap').value,
    team: el('fTeam').value,
  };
}

async function fetchRecords(filters){
  // Basic date filtering + optional tournament/map/team
  let q = client.from(TABLE_NAME).select('*');

  if(filters.from) q = q.gte('date', filters.from);
  if(filters.to)   q = q.lte('date', filters.to);

  if(filters.tournament && filters.tournament !== '__ALL__'){
    q = q.eq('tournament', filters.tournament);
  }
  if(filters.map && filters.map !== '__ALL__'){
    q = q.eq('map', filters.map);
  }
  if(filters.team && filters.team !== '__ALL__'){
    // Records can be stored as team_left/team_right OR team field; we’ll handle both later.
    // Here, be permissive: fetch all and filter in JS if needed.
  }

  const {data, error} = await q.order('date', {ascending:false}).limit(5000);
  if(error) throw error;
  return data || [];
}

/* ===========================
   NORMALIZATION helpers
=========================== */
function asArray(v){
  if(Array.isArray(v)) return v;
  if(v == null) return [];
  if(typeof v === 'string'){
    // try JSON parse if looks like array
    const s = v.trim();
    if((s.startsWith('[') && s.endsWith(']')) || (s.startsWith('{') && s.endsWith('}'))){
      try{
        const j = JSON.parse(s);
        if(Array.isArray(j)) return j;
      }catch(_){}
    }
    // fallback split
    return s.split(',').map(x=>x.trim()).filter(Boolean);
  }
  return [v];
}

function getTeamNamesFromRow(r){
  // Accept multiple schemas:
  // - team_left / team_right
  // - teamA / teamB
  // - team (single)
  const left = normName(r.team_left || r.teamA || r.team1 || '');
  const right = normName(r.team_right || r.teamB || r.team2 || '');
  const one = normName(r.team || '');
  const teams = [];
  if(left) teams.push(left);
  if(right) teams.push(right);
  if(!left && !right && one) teams.push(one);
  return teams;
}

function getWinnerFromRow(r){
  // Flexible winner fields
  const w = normName(r.winner || r.win_team || r.winning_team || r.team_win || '');
  return w;
}

function getMatchId(r){
  return String(r.match_id || r.id || r.game_id || `${r.date||''}-${r.map||''}-${r.round||''}-${r.match||''}` || '').trim();
}

function getPlayersFromRow(r, side){
  // side = 'left' or 'right'
  // Support:
  // - players_left (array), players_right
  // - team_left_players, team_right_players
  // - player1..player4 etc not supported unless provided as arrays
  const key1 = side === 'left' ? 'players_left' : 'players_right';
  const key2 = side === 'left' ? 'team_left_players' : 'team_right_players';
  const arr = asArray(r[key1] || r[key2]);
  // Normalize player object:
  return arr.map(p => {
    if(typeof p === 'string'){
      return { name: p, active: '', passives: [] };
    }
    return {
      name: normName(p.name || p.player || p.ign || ''),
      active: normName(p.active || p.hero || p.character || p.skill || ''),
      passives: asArray(p.passives || p.passive || p.passive_skills || p.passiveSkills || []),
    };
  });
}

function getBansFromRow(r){
  // Support:
  // - bans (array)
  // - bans_left + bans_right
  // - ban1.. etc
  const b = []
    .concat(asArray(r.bans))
    .concat(asArray(r.bans_left))
    .concat(asArray(r.bans_right))
    .concat(asArray(r.ban));
  const flat = b.map(x => {
    if(typeof x === 'string') return { name: normName(x) };
    return { name: normName(x.name || x.skill || x.character || '') , team: normName(x.team || '') };
  }).filter(x=>x.name);
  return flat;
}

function getActiveImageFromRow(r, activeName){
  // If row contains an images map, use it.
  // Otherwise fallback to character.json image if available.
  if(r && r.active_images){
    try{
      const m = typeof r.active_images === 'string' ? JSON.parse(r.active_images) : r.active_images;
      if(m && m[activeName]) return m[activeName];
    }catch(_){}
  }
  const info = getSkillInfo(activeName);
  return info?.image || '';
}

function getPassiveImageFromRow(r, passiveName){
  if(r && r.passive_images){
    try{
      const m = typeof r.passive_images === 'string' ? JSON.parse(r.passive_images) : r.passive_images;
      if(m && m[passiveName]) return m[passiveName];
    }catch(_){}
  }
  const info = getSkillInfo(passiveName);
  return info?.image || '';
}

function normalizeMatches(records){
  const byMatch = new Map();

  for(const r of records){
    const id = getMatchId(r);
    if(!id) continue;

    const teams = getTeamNamesFromRow(r);
    const left = normName(r.team_left || r.teamA || r.team1 || teams[0] || '');
    const right = normName(r.team_right || r.teamB || r.team2 || teams[1] || '');

    const m = {
      id,
      date: normName(r.date || ''),
      tournament: normName(r.tournament || ''),
      map: normName(r.map || ''),
      round: normName(r.round || r.stage || r.day || ''),
      leftTeam: left,
      rightTeam: right,
      winner: getWinnerFromRow(r),
      playersLeft: getPlayersFromRow(r, 'left'),
      playersRight: getPlayersFromRow(r, 'right'),
      bans: getBansFromRow(r),
      raw: r,
    };

    // optional: scores
    m.leftScore = Number(r.left_score || r.team_left_score || r.score_left || 0) || 0;
    m.rightScore = Number(r.right_score || r.team_right_score || r.score_right || 0) || 0;

    byMatch.set(id, m);
  }
  return Array.from(byMatch.values()).sort((a,b)=> (b.date||'').localeCompare(a.date||''));
}

/* ===========================
   FILTER OPTIONS
=========================== */
function uniqueSorted(arr){
  return Array.from(new Set(arr.filter(Boolean))).sort((a,b)=>a.localeCompare(b));
}

function populateTournamentDropdown(records){
  const sel = el('fTourn');
  const list = uniqueSorted(records.map(r => normName(r.tournament)));
  const prev = sel.value || DEFAULTS.tournament;
  sel.innerHTML = `<option value="__ALL__">All tournaments</option>` + list.map(x => `<option value="${escapeHtml(x)}">${escapeHtml(x)}</option>`).join('');
  sel.value = list.includes(prev) ? prev : (list[0] || '__ALL__');
}

function populateMapDropdown(records){
  const sel = el('fMap');
  const list = uniqueSorted(records.map(r => normName(r.map)));
  const prev = sel.value || DEFAULTS.map;
  sel.innerHTML = `<option value="__ALL__">All maps</option>` + list.map(x => `<option value="${escapeHtml(x)}">${escapeHtml(x)}</option>`).join('');
  sel.value = list.includes(prev) ? prev : '__ALL__';
}

function populateTeamDropdown(records){
  const sel = el('fTeam');
  const teams = [];
  for(const r of records){
    for(const t of getTeamNamesFromRow(r)) teams.push(t);
  }
  const list = uniqueSorted(teams);
  const prev = sel.value || DEFAULTS.team;
  sel.innerHTML = `<option value="__ALL__">All teams</option>` + list.map(x => `<option value="${escapeHtml(x)}">${escapeHtml(x)}</option>`).join('');
  sel.value = list.includes(prev) ? prev : '__ALL__';
}

/* ===========================
   RENDER: Matches
=========================== */
function computeKPIs(matches){
  const total = matches.length;
  let wins = 0;
  let picks = 0;
  let bans = 0;

  for(const m of matches){
    const w = normName(m.winner);
    if(w) wins++;

    // picks = actives across all players
    const players = m.playersLeft.concat(m.playersRight);
    picks += players.filter(p=>p.active).length;

    // bans
    bans += m.bans.length;
  }

  return {
    totalMatches: total,
    matchesWithWinner: wins,
    totalPicks: picks,
    totalBans: bans,
  };
}

function playerCardHTML(player, r){
  const hero = player.active || '';
  const heroImg = hero ? getActiveImageFromRow(r, hero) : '';
  const passives = asArray(player.passives).filter(Boolean);

  const passHTML = passives.length ? `
    <div class="pPass">
      ${passives.slice(0,6).map(ps=>{
        const img = getPassiveImageFromRow(r, ps);
        return `
          <div class="pPassItem">
            ${img ? `<img src="${escapeHtml(img)}" alt="${escapeHtml(ps)}" title="${escapeHtml(ps)}">` : ''}
            <span data-skill="${escapeHtml(ps)}">${escapeHtml(ps)}</span>
          </div>
        `;
      }).join('')}
    </div>
  ` : '';

  return `
    <div class="player">
      <div class="pInfo">
        <div class="pName">${escapeHtml(player.name || '—')}</div>
        <div class="pHero" data-skill="${escapeHtml(hero)}">${escapeHtml(hero || '—')}</div>
        ${passHTML}
      </div>
      <div class="pActs">
        ${hero ? `<img class="pAct" src="${escapeHtml(heroImg)}" alt="${escapeHtml(hero)}" title="${escapeHtml(hero)}">` : ''}
      </div>
    </div>
  `;
}

function renderMatchList(matches, filters){
  const list = el('matchList');
  el('matchCount').textContent = fmtNum(matches.length);

  if(!matches.length){
    list.innerHTML = `<div class="muted">No matches found for the selected filters.</div>`;
    return;
  }

  const teamFilter = filters.team;

  const html = matches.map(m=>{
    // optional team filter in JS (if schema doesn't allow eq in query)
    if(teamFilter && teamFilter !== '__ALL__'){
      const teams = [m.leftTeam, m.rightTeam].filter(Boolean);
      if(!teams.includes(teamFilter)) return '';
    }

    const winner = normName(m.winner);
    const wTag = winner ? `<span class="badge">Winner: <span class="mono">${escapeHtml(winner)}</span></span>` : `<span class="badge">Winner: <span class="mono">—</span></span>`;
    const meta = `
      <span class="badge mono">${escapeHtml(m.date || '—')}</span>
      <span class="badge mono">${escapeHtml(m.tournament || '—')}</span>
      <span class="badge mono">${escapeHtml(m.map || '—')}</span>
      ${m.round ? `<span class="badge mono">${escapeHtml(m.round)}</span>` : ''}
      ${wTag}
    `;

    const bans = m.bans || [];
    const bansHTML = bans.length ? `
      <div class="bansGrid">
        ${bans.slice(0,10).map(b=>{
          const img = getActiveImageFromRow(m.raw, b.name) || getPassiveImageFromRow(m.raw, b.name);
          return `
            <div class="banCell">
              ${img ? `<img src="${escapeHtml(img)}" alt="${escapeHtml(b.name)}" title="${escapeHtml(b.name)}">` : ''}
              <div style="min-width:0">
                <div class="bn" data-skill="${escapeHtml(b.name)}">${escapeHtml(b.name)}</div>
                <div class="bt">${escapeHtml(b.team || '')}</div>
              </div>
            </div>
          `;
        }).join('')}
      </div>
    ` : `<div class="muted">No bans recorded.</div>`;

    return `
      <div class="match">
        <div class="matchHead">
          <div class="matchTitle">${escapeHtml(m.leftTeam || 'Team A')} vs ${escapeHtml(m.rightTeam || 'Team B')}</div>
          <div class="matchMeta">${meta}</div>
        </div>
        <div class="row">
          <div class="teamBox">
            <div class="teamName"><span class="miniDot"></span>${escapeHtml(m.leftTeam || '—')}</div>
            <div class="playersWrap">
              ${m.playersLeft.map(p => playerCardHTML(p, m.raw)).join('') || `<div class="muted">No players</div>`}
            </div>
          </div>
          <div class="teamBox">
            <div class="teamName"><span class="miniDot" style="background:rgba(255,189,89,.85)"></span>${escapeHtml(m.rightTeam || '—')}</div>
            <div class="playersWrap">
              ${m.playersRight.map(p => playerCardHTML(p, m.raw)).join('') || `<div class="muted">No players</div>`}
            </div>
          </div>
          <div class="bansBox">
            <div class="teamName"><span class="miniDot" style="background:rgba(120,150,255,.75)"></span>Bans</div>
            ${bansHTML}
          </div>
        </div>
      </div>
    `;
  }).filter(Boolean).join('');

  list.innerHTML = html || `<div class="muted">No matches found for the selected team filter.</div>`;
}

function computeTopSkills(matches, subject){
  const count = new Map();
  const wins = new Map();

  for(const m of matches){
    const winner = normName(m.winner);
    const didWin = (t) => winner && (winner === t);

    if(subject === 'active'){
      const players = m.playersLeft.concat(m.playersRight);
      for(const p of players){
        const s = normName(p.active);
        if(!s) continue;
        count.set(s, (count.get(s)||0) + 1);

        // if player belongs to winning team, count as win appearance
        const team = m.playersLeft.includes(p) ? m.leftTeam : m.rightTeam;
        if(didWin(team)) wins.set(s, (wins.get(s)||0) + 1);
      }
    }else if(subject === 'passive'){
      const players = m.playersLeft.concat(m.playersRight);
      for(const p of players){
        const team = m.playersLeft.includes(p) ? m.leftTeam : m.rightTeam;
        for(const ps of asArray(p.passives)){
          const s = normName(ps);
          if(!s) continue;
          count.set(s, (count.get(s)||0) + 1);
          if(didWin(team)) wins.set(s, (wins.get(s)||0) + 1);
        }
      }
    }else if(subject === 'bans'){
      for(const b of (m.bans||[])){
        const s = normName(b.name);
        if(!s) continue;
        count.set(s, (count.get(s)||0) + 1);
        // wins not meaningful for bans, skip
      }
    }
  }

  const rows = Array.from(count.entries()).map(([name, c]) => {
    const w = wins.get(name) || 0;
    return { name, count:c, winRate: c ? (w/c) : 0 };
  }).sort((a,b)=> b.count - a.count);

  return rows.slice(0, 8);
}

function renderTopList(elm, rows, type){
  if(!rows.length){
    elm.innerHTML = `<div class="muted">—</div>`;
    return;
  }
  elm.innerHTML = rows.map(r => {
    const info = getSkillInfo(r.name);
    const img = info?.image || '';
    const wr = type === 'bans' ? '' : `<span class="muted">• WR ${fmtPct(r.winRate)}</span>`;
    return `
      <div class="pill" style="margin:6px 0; width:100%; justify-content:space-between">
        <span class="skill-cell" style="gap:8px">
          ${img ? `<img src="${escapeHtml(img)}" alt="${escapeHtml(r.name)}">` : ''}
          <span class="mono" data-skill="${escapeHtml(r.name)}">${escapeHtml(r.name)}</span>
        </span>
        <span class="mono">${fmtNum(r.count)} ${wr}</span>
      </div>
    `;
  }).join('');
}

function renderKPIs(matches){
  const kpi = computeKPIs(matches);
  const row = el('kpiRow');
  row.innerHTML = `
    <span class="pill"><span class="dot"></span><span class="mono">Matches: ${fmtNum(kpi.totalMatches)}</span></span>
    <span class="pill"><span class="dot" style="background:rgba(120,150,255,.8)"></span><span class="mono">Picks: ${fmtNum(kpi.totalPicks)}</span></span>
    <span class="pill"><span class="dot" style="background:rgba(255,119,51,.8)"></span><span class="mono">Bans: ${fmtNum(kpi.totalBans)}</span></span>
  `;
}

/* ===========================
   SUMMARY VIEW
=========================== */
function groupKey(match, groupBy){
  if(groupBy === 'team') return '__TEAM__'; // handled below
  if(groupBy === 'map') return match.map || '—';
  if(groupBy === 'tournament') return match.tournament || '—';
  return '—';
}

function buildSummaryGroups(matches, groupBy){
  const groups = new Map();

  if(groupBy === 'team'){
    for(const m of matches){
      const t1 = m.leftTeam || '—';
      const t2 = m.rightTeam || '—';
      if(!groups.has(t1)) groups.set(t1, []);
      if(!groups.has(t2)) groups.set(t2, []);
      groups.get(t1).push(m);
      groups.get(t2).push(m);
    }
    return groups;
  }

  for(const m of matches){
    const k = groupKey(m, groupBy) || '—';
    if(!groups.has(k)) groups.set(k, []);
    groups.get(k).push(m);
  }
  return groups;
}

function buildSkillCounts(matches, subject, groupKeyName){
  const count = new Map();
  const wins = new Map();
  const appearedInMatch = new Set();

  for(const m of matches){
    const winner = normName(m.winner);
    const teamWin = (team) => winner && team && winner === team;

    if(subject === 'active'){
      const players = m.playersLeft.concat(m.playersRight);
      for(const p of players){
        const s = normName(p.active);
        if(!s) continue;

        count.set(s, (count.get(s)||0)+1);

        const team = m.playersLeft.includes(p) ? m.leftTeam : m.rightTeam;
        if(teamWin(team)) wins.set(s, (wins.get(s)||0)+1);

        appearedInMatch.add(`${m.id}::${s}`);
      }
    }else if(subject === 'passive'){
      const players = m.playersLeft.concat(m.playersRight);
      for(const p of players){
        const team = m.playersLeft.includes(p) ? m.leftTeam : m.rightTeam;
        for(const ps of asArray(p.passives)){
          const s = normName(ps);
          if(!s) continue;
          count.set(s, (count.get(s)||0)+1);
          if(teamWin(team)) wins.set(s, (wins.get(s)||0)+1);
          appearedInMatch.add(`${m.id}::${s}`);
        }
      }
    }else if(subject === 'bans'){
      for(const b of (m.bans||[])){
        const s = normName(b.name);
        if(!s) continue;
        count.set(s, (count.get(s)||0)+1);
        appearedInMatch.add(`${m.id}::${s}`);
      }
    }
  }

  const rows = Array.from(count.entries()).map(([name,c])=>{
    const w = wins.get(name)||0;
    return {
      name,
      count:c,
      pickRate: matches.length ? (appearedInMatchCount(appearedInMatch, name, matches) / matches.length) : 0,
      winRate: subject === 'bans' ? 0 : (c ? (w/c) : 0)
    };
  }).sort((a,b)=> b.count - a.count);

  return rows;
}

function appearedInMatchCount(set, skillName, matches){
  let n = 0;
  for(const m of matches){
    if(set.has(`${m.id}::${skillName}`)) n++;
  }
  return n;
}

function renderSummary(matches){
  const groupBy = el('sumGroup').value;
  const subject = el('sumSubject').value;
  const minCount = Number(el('sumMin').value || 1);

  const groups = buildSummaryGroups(matches, groupBy);
  const keys = Array.from(groups.keys()).sort((a,b)=>a.localeCompare(b));

  el('sumMeta').textContent = `${fmtNum(keys.length)} ${groupBy} group(s) • ${fmtNum(keys.reduce((acc,k)=>acc + groups.get(k).length, 0))} match-row(s) in view`;

  const cards = [];
  for(const k of keys){
    const ms = groups.get(k) || [];
    const winnerMatches = ms.filter(x => !!normName(x.winner)).length;

    // Team-specific wins only for groupBy=team
    let wins = 0;
    if(groupBy === 'team'){
      for(const m of ms){
        if(normName(m.winner) && m.winner === k) wins++;
      }
    }

    const skills = buildSkillCounts(ms, subject, k).filter(r => r.count >= minCount).slice(0, 12);

    const kpis = groupBy === 'team'
      ? `<div class="kpis">
          <span class="chip mono">Matches ${fmtNum(ms.length)}</span>
          <span class="chip mono">Wins ${fmtNum(wins)} (${ms.length?fmtPct(wins/ms.length):'0.0%'})</span>
          <span class="chip mono">When Appeared ${fmtPct(skills.length?skills[0].pickRate:0)}</span>
        </div>`
      : `<div class="kpis">
          <span class="chip mono">Matches ${fmtNum(ms.length)}</span>
          <span class="chip mono">Winners logged ${fmtNum(winnerMatches)}</span>
        </div>`;

    const table = skills.length ? `
      <div class="tableWrap"><table class="sum-table">
        <thead>
          <tr>
            <th>${subject === 'bans' ? 'Skill' : 'Skill'}</th>
            <th class="right">Count</th>
            <th class="right">${subject === 'bans' ? 'Ban Rate' : 'Pick Rate'}</th>
            <th class="right">${subject === 'bans' ? '—' : 'Win Rate'}</th>
          </tr>
        </thead>
        <tbody>
          ${skills.map(s=>{
            const info = getSkillInfo(s.name);
            const img = info?.image || '';
            return `
              <tr>
                <td>
                  <div class="skill-cell">
                    ${img ? `<img src="${escapeHtml(img)}" alt="${escapeHtml(s.name)}">` : ''}
                    <span class="skill-name" data-skill="${escapeHtml(s.name)}">${escapeHtml(s.name)}</span>
                  </div>
                </td>
                <td class="right mono">${fmtNum(s.count)}</td>
                <td class="right mono">${fmtPct(s.pickRate)}</td>
                <td class="right mono">${subject === 'bans' ? '—' : fmtPct(s.winRate)}</td>
              </tr>
            `;
          }).join('')}
        </tbody>
      </table></div>`
      : `<div class="muted">No ${subject} data for this group.</div>`;

    cards.push(`
      <div class="card">
        <h4><span>${escapeHtml(k || '—')}</span><span class="muted mono">${groupBy}</span></h4>
        ${kpis}
        ${table}
      </div>
    `);
  }

  el('summaryCards').innerHTML = cards.join('') || `<div class="muted">No groups to display.</div>`;
}

/* ===========================
   TEAM × MAP VIEW
=========================== */
function computeSkillStats(matches){
  // Build per-map stats for actives
  const perMap = new Map(); // map -> skill -> {count, wins, matchesAppeared}
  const allMaps = new Set();

  for(const m of matches){
    const map = m.map || '—';
    allMaps.add(map);
    if(!perMap.has(map)) perMap.set(map, new Map());
    const mm = perMap.get(map);

    const winner = normName(m.winner);

    // active picks
    const players = m.playersLeft.concat(m.playersRight);
    const appeared = new Set();

    for(const p of players){
      const s = normName(p.active);
      if(!s) continue;
      if(!mm.has(s)) mm.set(s, {count:0,wins:0,appeared:0});
      const rec = mm.get(s);
      rec.count += 1;

      const team = m.playersLeft.includes(p) ? m.leftTeam : m.rightTeam;
      if(winner && team && winner === team) rec.wins += 1;

      appeared.add(s);
    }

    for(const s of appeared){
      mm.get(s).appeared += 1;
    }
  }

  return { perMap, maps: Array.from(allMaps).sort((a,b)=>a.localeCompare(b)) };
}

function renderSkillByMap(matches){
  const {perMap, maps} = computeSkillStats(matches);
  el('tmMeta1').textContent = `${fmtNum(maps.length)} map(s)`;

  if(!maps.length){
    el('tmTable1').innerHTML = `<div class="muted">No data.</div>`;
    return;
  }

  // Aggregate across selected maps
  const agg = new Map(); // skill -> {count, wins, appeared, matches}
  const totalMatches = matches.length;

  for(const map of maps){
    const mm = perMap.get(map);
    for(const [skill, rec] of mm.entries()){
      if(!agg.has(skill)) agg.set(skill, {count:0,wins:0,appeared:0});
      const a = agg.get(skill);
      a.count += rec.count;
      a.wins += rec.wins;
      a.appeared += rec.appeared;
    }
  }

  const rows = Array.from(agg.entries()).map(([name, r]) => ({
    name,
    count:r.count,
    pickRate: totalMatches ? (r.appeared/totalMatches) : 0,
    winRate: r.count ? (r.wins/r.count) : 0,
  })).sort((a,b)=> b.count - a.count).slice(0, 25);

  el('tmTable1').innerHTML = `
    <table class="sum-table skill-table">
      <thead>
        <tr>
          <th>Skill</th>
          <th class="right">Count</th>
          <th class="right">Pick Rate</th>
          <th class="right">Win Rate</th>
        </tr>
      </thead>
      <tbody>
        ${rows.map(r=>{
          const info = getSkillInfo(r.name);
          const img = info?.image || '';
          return `
            <tr>
              <td>
                <div class="skill-cell">
                  ${img ? `<img src="${escapeHtml(img)}" alt="${escapeHtml(r.name)}">` : ''}
                  <span class="skill-name" data-skill="${escapeHtml(r.name)}">${escapeHtml(r.name)}</span>
                </div>
              </td>
              <td class="right mono">${fmtNum(r.count)}</td>
              <td class="right mono">${fmtPct(r.pickRate)}</td>
              <td class="right mono">${fmtPct(r.winRate)}</td>
            </tr>
          `;
        }).join('')}
      </tbody>
    </table>
  `;
}

function computeBanImpact(matches){
  // For each banned skill, compute banning-team performance (win rate)
  const banMap = new Map(); // skill -> {bans, banMatches, wins}
  for(const m of matches){
    const winner = normName(m.winner);
    if(!m.bans || !m.bans.length) continue;

    for(const b of m.bans){
      const s = normName(b.name);
      if(!s) continue;
      if(!banMap.has(s)) banMap.set(s, {bans:0, matches:0, wins:0});
      const rec = banMap.get(s);
      rec.bans += 1;
      rec.matches += 1;
      if(winner && b.team && winner === b.team) rec.wins += 1;
    }
  }
  const rows = Array.from(banMap.entries()).map(([name,r])=>({
    name,
    bans:r.bans,
    winRate: r.matches ? (r.wins/r.matches) : 0
  })).sort((a,b)=> b.bans - a.bans).slice(0, 25);

  return rows;
}

function renderBanImpact(matches){
  const rows = computeBanImpact(matches);
  el('tmMeta2').textContent = `${fmtNum(rows.length)} skill(s)`;

  if(!rows.length){
    el('tmTable2').innerHTML = `<div class="muted">No ban data found.</div>`;
    return;
  }

  el('tmTable2').innerHTML = `
    <table class="sum-table skill-table">
      <thead>
        <tr>
          <th>Skill</th>
          <th class="right">Bans</th>
          <th class="right">Banning Team WR</th>
        </tr>
      </thead>
      <tbody>
        ${rows.map(r=>{
          const info = getSkillInfo(r.name);
          const img = info?.image || '';
          return `
            <tr>
              <td>
                <div class="skill-cell">
                  ${img ? `<img src="${escapeHtml(img)}" alt="${escapeHtml(r.name)}">` : ''}
                  <span class="skill-name" data-skill="${escapeHtml(r.name)}">${escapeHtml(r.name)}</span>
                </div>
              </td>
              <td class="right mono">${fmtNum(r.bans)}</td>
              <td class="right mono">${fmtPct(r.winRate)}</td>
            </tr>
          `;
        }).join('')}
      </tbody>
    </table>
  `;
}

function computePairs(matches){
  // Pairings within same player: two actives not possible (one active), so do passive pairs per player
  // Team-wide combos: top 3 actives per team per match (set)
  const passivePairs = new Map(); // "A||B" -> {count,wins}
  const teamCombos = new Map(); // "A+B+C" -> {count,wins}

  for(const m of matches){
    const winner = normName(m.winner);

    // passive pairs
    const players = m.playersLeft.concat(m.playersRight);
    for(const p of players){
      const team = m.playersLeft.includes(p) ? m.leftTeam : m.rightTeam;
      const pass = asArray(p.passives).map(normName).filter(Boolean);
      for(let i=0;i<pass.length;i++){
        for(let j=i+1;j<pass.length;j++){
          const a = pass[i], b = pass[j];
          const key = [a,b].sort().join('||');
          if(!passivePairs.has(key)) passivePairs.set(key, {count:0,wins:0,a:[a,b]});
          const rec = passivePairs.get(key);
          rec.count += 1;
          if(winner && team && winner === team) rec.wins += 1;
        }
      }
    }

    // team combos by actives
    const teamSides = [
      {team:m.leftTeam, players:m.playersLeft},
      {team:m.rightTeam, players:m.playersRight},
    ];
    for(const side of teamSides){
      const actives = side.players.map(p=>normName(p.active)).filter(Boolean);
      const set = Array.from(new Set(actives)).sort();
      if(!set.length) continue;
      const key = set.join(' + ');
      if(!teamCombos.has(key)) teamCombos.set(key, {count:0,wins:0, skills:set});
      const rec = teamCombos.get(key);
      rec.count += 1;
      if(winner && side.team && winner === side.team) rec.wins += 1;
    }
  }

  const pairRows = Array.from(passivePairs.entries()).map(([k,r])=>({
    key:k,
    a:r.a[0],
    b:r.a[1],
    count:r.count,
    winRate: r.count ? (r.wins/r.count) : 0
  })).sort((x,y)=> y.count-x.count).slice(0, 20);

  const comboRows = Array.from(teamCombos.entries()).map(([k,r])=>({
    key:k,
    skills:r.skills,
    count:r.count,
    winRate: r.count ? (r.wins/r.count) : 0
  })).sort((x,y)=> y.count-x.count).slice(0, 20);

  return {pairRows, comboRows};
}

function renderCombos(matches){
  const {pairRows, comboRows} = computePairs(matches);
  el('tmMeta3').textContent = `${fmtNum(pairRows.length)} pairs • ${fmtNum(comboRows.length)} combos`;

  const iconRow = (name) => {
    const info = getSkillInfo(name);
    const img = info?.image || '';
    return img ? `<img src="${escapeHtml(img)}" alt="${escapeHtml(name)}" title="${escapeHtml(name)}">` : '';
  };

  const pairTable = pairRows.length ? `
    <h4 style="margin:0 0 8px;font-size:.92rem;color:var(--muted)">Passive pairs (same player)</h4>
    <table class="sum-table skill-table">
      <thead>
        <tr>
          <th>Pair</th>
          <th class="right">Count</th>
          <th class="right">Win Rate</th>
        </tr>
      </thead>
      <tbody>
        ${pairRows.map(r=>{
          return `
            <tr>
              <td>
                <div class="skill-cell comboIcons" style="gap:8px">
                  ${iconRow(r.a)}${iconRow(r.b)}
                  <span class="skill-name" data-skill="${escapeHtml(r.a)}">${escapeHtml(r.a)}</span>
                  <span class="muted">+</span>
                  <span class="skill-name" data-skill="${escapeHtml(r.b)}">${escapeHtml(r.b)}</span>
                </div>
              </td>
              <td class="right mono">${fmtNum(r.count)}</td>
              <td class="right mono">${fmtPct(r.winRate)}</td>
            </tr>
          `;
        }).join('')}
      </tbody>
    </table>
  ` : `<div class="muted">No passive pair data.</div>`;

  const comboTable = comboRows.length ? `
    <h4 style="margin:14px 0 8px;font-size:.92rem;color:var(--muted)">Team active combos (per team per match)</h4>
    <table class="sum-table skill-table">
      <thead>
        <tr>
          <th>Combo</th>
          <th class="right">Count</th>
          <th class="right">Win Rate</th>
        </tr>
      </thead>
      <tbody>
        ${comboRows.map(r=>{
          const icons = r.skills.slice(0,6).map(iconRow).join('');
          return `
            <tr>
              <td>
                <div class="skill-cell comboIcons" style="gap:8px">
                  <span class="icons" style="display:flex;gap:6px;flex-wrap:wrap">${icons}</span>
                  <span class="mono" style="color:var(--muted)">${escapeHtml(r.key)}</span>
                </div>
              </td>
              <td class="right mono">${fmtNum(r.count)}</td>
              <td class="right mono">${fmtPct(r.winRate)}</td>
            </tr>
          `;
        }).join('')}
      </tbody>
    </table>
  ` : `<div class="muted">No team combo data.</div>`;

  el('tmTable3').innerHTML = pairTable + comboTable;
}

function computePassiveBundles(matches){
  const bundles = new Map(); // "A+B+C" -> {count,wins}
  for(const m of matches){
    const winner = normName(m.winner);
    const players = m.playersLeft.concat(m.playersRight);

    for(const p of players){
      const team = m.playersLeft.includes(p) ? m.leftTeam : m.rightTeam;
      const pass = Array.from(new Set(asArray(p.passives).map(normName).filter(Boolean))).sort();
      if(!pass.length) continue;
      const key = pass.join(' + ');
      if(!bundles.has(key)) bundles.set(key, {count:0,wins:0, skills:pass});
      const rec = bundles.get(key);
      rec.count += 1;
      if(winner && team && winner === team) rec.wins += 1;
    }
  }

  const rows = Array.from(bundles.entries()).map(([k,r])=>({
    key:k,
    skills:r.skills,
    count:r.count,
    winRate: r.count ? (r.wins/r.count) : 0
  })).sort((a,b)=> b.count-a.count).slice(0, 25);

  return rows;
}

function renderPassiveBundles(matches){
  const rows = computePassiveBundles(matches);
  el('tmMeta4').textContent = `${fmtNum(rows.length)} bundle(s)`;

  if(!rows.length){
    el('tmTable4').innerHTML = `<div class="muted">No passive bundle data.</div>`;
    return;
  }

  const iconRow = (name) => {
    const info = getSkillInfo(name);
    const img = info?.image || '';
    return img ? `<img src="${escapeHtml(img)}" alt="${escapeHtml(name)}" title="${escapeHtml(name)}">` : '';
  };

  el('tmTable4').innerHTML = `
    <table class="sum-table skill-table">
      <thead>
        <tr>
          <th>Bundle</th>
          <th class="right">Count</th>
          <th class="right">Win Rate</th>
        </tr>
      </thead>
      <tbody>
        ${rows.map(r=>{
          const icons = r.skills.slice(0,6).map(iconRow).join('');
          return `
            <tr>
              <td>
                <div class="skill-cell icons" style="gap:10px">
                  <span class="icons" style="display:flex;gap:6px;flex-wrap:wrap">${icons}</span>
                  <span class="mono" style="color:var(--muted)">${escapeHtml(r.key)}</span>
                </div>
              </td>
              <td class="right mono">${fmtNum(r.count)}</td>
              <td class="right mono">${fmtPct(r.winRate)}</td>
            </tr>
          `;
        }).join('')}
      </tbody>
    </table>
  `;
}

/* ===========================
   EXPORT CSV
=========================== */
function downloadCSV(filename, rows){
  const csv = rows.map(r => r.map(v => `"${String(v??'').replace(/"/g,'""')}"`).join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
}

function exportCurrent(){
  const tab = document.querySelector('.tab.active')?.dataset?.tab || 'matches';
  if(tab === 'matches'){
    const rows = [
      ['match_id','date','tournament','map','left_team','right_team','winner','bans_count','picks_count']
    ];
    for(const m of RAW_MATCHES){
      const picks = m.playersLeft.concat(m.playersRight).filter(p=>p.active).length;
      rows.push([
        m.id, m.date, m.tournament, m.map, m.leftTeam, m.rightTeam, m.winner, (m.bans||[]).length, picks
      ]);
    }
    downloadCSV('cs_skills_matches.csv', rows);
  }else if(tab === 'summary'){
    // Export current summary view table (flatten)
    const groupBy = el('sumGroup').value;
    const subject = el('sumSubject').value;
    const minCount = Number(el('sumMin').value || 1);
    const groups = buildSummaryGroups(RAW_MATCHES, groupBy);
    const keys = Array.from(groups.keys()).sort((a,b)=>a.localeCompare(b));

    const rows = [['group', 'skill', 'count', 'pick_rate', 'win_rate']];
    for(const k of keys){
      const ms = groups.get(k) || [];
      const skills = buildSkillCounts(ms, subject, k).filter(r=>r.count>=minCount).slice(0, 200);
      for(const s of skills){
        rows.push([k, s.name, s.count, s.pickRate, s.winRate]);
      }
    }
    downloadCSV('cs_skills_summary.csv', rows);
  }else{
    // teammap: export top actives by map + ban impact
    const skillStats = computeSkillStats(RAW_MATCHES);
    const maps = skillStats.maps;
    const rows = [['map','skill','count','appeared_matches']];
    for(const map of maps){
      const mm = skillStats.perMap.get(map);
      const list = Array.from(mm.entries()).map(([name,r])=>({name, ...r})).sort((a,b)=>b.count-a.count).slice(0, 50);
      for(const it of list){
        rows.push([map, it.name, it.count, it.appeared]);
      }
    }
    downloadCSV('cs_skills_teammap.csv', rows);
  }
}

/* ===========================
   PAGE: Tabs
=========================== */
function setActiveTab(tabName){
  document.querySelectorAll('.tab').forEach(t=>{
    const active = t.dataset.tab === tabName;
    t.classList.toggle('active', active);
    t.setAttribute('aria-selected', active ? 'true' : 'false');
  });

  el('viewMatches').style.display = tabName === 'matches' ? '' : 'none';
  el('viewSummary').style.display = tabName === 'summary' ? '' : 'none';
  el('viewTeamMap').style.display = tabName === 'teammap' ? '' : 'none';
}

/* ===========================
   APPLY / REFRESH
=========================== */
function setPills(filters){
  el('pillMatches').textContent = `Loaded ${fmtNum(RAW_MATCHES.length)} matches`;
  el('pillTeam').textContent = `Team: ${(filters.team==='__ALL__') ? 'All teams' : filters.team}`;
  el('pillMap').textContent = `Map: ${(filters.map==='__ALL__') ? 'All maps' : filters.map}`;
  el('pillTourn').textContent = `Tournament: ${(filters.tournament==='__ALL__') ? 'All tournaments' : filters.tournament}`;
  el('lastSync').textContent = `Last sync: ${new Date().toLocaleString()}`;
}

function filterMatchesByTeam(matches, team){
  if(!team || team === '__ALL__') return matches;
  return matches.filter(m => m.leftTeam === team || m.rightTeam === team);
}

async function refresh(){
  const filters = getFilters();

  el('matchList').innerHTML = `<div class="muted">Loading…</div>`;
  try{
    RAW_RECORDS = await fetchRecords(filters);
    // Keep dropdowns linked to current view (tournament drives team list, etc.)
    populateTournamentDropdown(RAW_RECORDS);
    populateMapDropdown(RAW_RECORDS);
    populateTeamDropdown(RAW_RECORDS);

    RAW_MATCHES = normalizeMatches(RAW_RECORDS);

    // Apply team filter (JS-side)
    const viewMatches = filterMatchesByTeam(RAW_MATCHES, filters.team);

    setPills(filters);

    // Matches view renders
    renderKPIs(viewMatches);
    renderMatchList(viewMatches, filters);

    renderTopList(el('topActive'), computeTopSkills(viewMatches, 'active'), 'active');
    renderTopList(el('topPassive'), computeTopSkills(viewMatches, 'passive'), 'passive');

    // Summary view render
    renderSummary(viewMatches);

    // Team × Map view render
    renderSkillByMap(viewMatches);
    renderBanImpact(viewMatches);
    renderCombos(viewMatches);
    renderPassiveBundles(viewMatches);

  }catch(err){
    console.error(err);
    el('matchList').innerHTML = `<div class="muted">Error loading data: ${escapeHtml(err.message || String(err))}</div>`;
    el('summaryCards').innerHTML = `<div class="muted">Error loading summary.</div>`;
    el('tmTable1').innerHTML = `<div class="muted">Error.</div>`;
    el('tmTable2').innerHTML = `<div class="muted">Error.</div>`;
    el('tmTable3').innerHTML = `<div class="muted">Error.</div>`;
    el('tmTable4').innerHTML = `<div class="muted">Error.</div>`;
  }
}

/* ===========================
   DEFAULT DATE RANGE + Latest Tournament
=========================== */
function setDefaultDates(){
  const today = new Date();
  const to = toISODate(today);
  const from = toISODate(new Date(today.getTime() - 1000*60*60*24*30)); // last 30 days
  el('fFrom').value = from;
  el('fTo').value = to;
}

async function getLatestTournament(records){
  // latest tournament by max(date) then tournament name
  const rows = records
    .filter(r => r.tournament && r.date)
    .sort((a,b)=> String(b.date).localeCompare(String(a.date)));
  return rows[0]?.tournament || '__ALL__';
}

async function getTournamentStartDate(tourn){
  // Find min date for a tournament among current raw records (or query)
  // We'll query a small sample for min date.
  try{
    const {data, error} = await client
      .from(TABLE_NAME)
      .select('date')
      .eq('tournament', tourn)
      .order('date', {ascending:true})
      .limit(1);
    if(error) throw error;
    return data?.[0]?.date || '';
  }catch(_){
    return '';
  }
}

/* ===========================
   INIT
=========================== */
document.querySelectorAll('.tab').forEach(t=>{
  t.addEventListener('click', () => setActiveTab(t.dataset.tab));
});

el('btnApply').addEventListener('click', refresh);
el('btnRefresh').addEventListener('click', refresh);

el('btnReset').addEventListener('click', () => {
  setDefaultDates();
  el('fMap').value = '__ALL__';
  el('fTeam').value = '__ALL__';
  el('fTourn').value = '__ALL__';
  refresh();
});

el('btnExport').addEventListener('click', exportCurrent);

el('btnRecalc').addEventListener('click', () => {
  const filters = getFilters();
  const viewMatches = filterMatchesByTeam(RAW_MATCHES, filters.team);
  renderSummary(viewMatches);
});

['sumGroup','sumSubject','sumMin'].forEach(id=>{
  el(id).addEventListener('change', () => {
    const filters = getFilters();
    const viewMatches = filterMatchesByTeam(RAW_MATCHES, filters.team);
    renderSummary(viewMatches);
  });
});

// Tournament change should re-link team dropdown (and default to tournament start)
el('fTourn').addEventListener('change', async () => {
  const tourn = el('fTourn').value;
  if(tourn && tourn !== '__ALL__'){
    const start = await getTournamentStartDate(tourn);
    if(start) el('fFrom').value = start;
  }
  // reset team to All when switching tournaments (avoid empty results)
  el('fTeam').value = '__ALL__';
  refresh();
});

// Map change refresh
el('fMap').addEventListener('change', () => refresh());

// Team change refresh (optional)
el('fTeam').addEventListener('change', () => refresh());

(async function init(){
  bindSkillTooltipDelegation();
  setDefaultDates();
  await loadCharacterJSON();

  // Initial fetch to populate dropdowns and auto-select latest tournament
  try{
    const baseFilters = getFilters();
    RAW_RECORDS = await fetchRecords(baseFilters);

    populateTournamentDropdown(RAW_RECORDS);
    populateMapDropdown(RAW_RECORDS);
    populateTeamDropdown(RAW_RECORDS);

    const latest = await getLatestTournament(RAW_RECORDS);
    if(latest && latest !== '__ALL__'){
      el('fTourn').value = latest;
      const start = await getTournamentStartDate(latest);
      if(start) el('fFrom').value = start;
    }

  }catch(err){
    console.warn('Initial dropdown load failed:', err);
  }

  await refresh();
})();
</script>
</body>
</html>
