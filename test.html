<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FFBR — LOPS Dashboard</title>
<meta name="theme-color" content="#0d1014"/>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<style>
  :root{
    --bg:#0d1014; --panel:#292d42; --panel2:#1e2432; --ink:#f3f6fa; --muted:#b8c0cc;
    --brand:#ffe93b; --brandText:#0b0d0e; --line:#4c525d; --chip:#213830;
    --good:#62e887; --bad:#ff6b6b; --accent:#7fd2ff;

    /* Heatmap look */
    --heat-rgb: 255,233,59;      /* brand yellow */
    --heat-min: .06;
    --heat-max: .24;
    --heat-outline: .45;
    --heat-radius: 8px;
  }

  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif}
  header{position:sticky;top:0;z-index:5;background:#111622;border-bottom:3px solid var(--brand);padding:14px 16px}
  h1{margin:0;font-size:1.12rem;letter-spacing:.3px;color:var(--brand)}
  .user-controls{position:absolute;right:16px;top:12px;display:flex;gap:10px;align-items:center}
  .chip{font-size:.85rem;color:#ddd}
  .btn{background:var(--brand);color:#111;border:0;border-radius:10px;padding:9px 12px;font-weight:800;cursor:pointer;text-decoration:none;display:inline-flex;align-items:center;gap:8px}
  .btn.secondary{background:#172033;color:#d8e0ef;border:1px solid #2e3b54}
  .btn.ghost{background:transparent;border:1px dashed #40506f;color:#cbd4e6}
  .shell{max-width:1180px;margin:20px auto;padding:0 12px}

  .section{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:12px;margin-bottom:14px}
  .section h2{margin:0 0 10px;color:var(--brand)}
  .bar{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .input, select{background:#121826;color:#e7eefb;border:1px solid #31415f;border-radius:10px;padding:8px 10px;min-height:38px}
  .input::placeholder{color:#9fb0cf}
  .pill{background:#172033;padding:4px 8px;border-radius:999px;color:#c5d0e6;border:1px solid #2d3b57}
  .muted{color:var(--muted)}

  .kpis{display:grid;grid-template-columns:repeat(6,minmax(120px,1fr));gap:10px}
  .kpi{background:var(--panel2);border:1px solid var(--line);border-radius:12px;padding:10px}
  .kpi .t{font-size:.8rem;letter-spacing:.3px;color:#b7c2da}
  .kpi .v{font-size:1.3rem;font-weight:800}

  table{width:100%;border-collapse:separate;border-spacing:0 8px;font-size:.95rem}
  thead th{background:#141a28;text-align:left;border-radius:10px;padding:8px 8px}
  tbody td{background:#0f1522;border:1px solid #273350}
  th,td{padding:8px 8px;vertical-align:top}
  td{border-radius:10px}
  td.right, th.right{text-align:right}

  .sortbar{display:flex;gap:8px;align-items:center;margin-bottom:8px;flex-wrap:wrap}

  details.accordion{
    background:var(--panel);
    border:1px solid var(--line);
    border-radius:14px;
    padding:0;margin-bottom:14px;
  }
  details.accordion > summary{
    list-style:none;cursor:pointer;padding:12px 14px;color:var(--brand);font-weight:800;border-bottom:1px solid var(--line);user-select:none;
  }
  details.accordion[open] > summary{ border-bottom-color:var(--line); }
  details.accordion > .accordion-body{ padding:12px; }

  /* Heat cells */
  td[data-key]{ transition: background-color .18s ease, box-shadow .18s ease; border-radius: var(--heat-radius); background-clip: padding-box; }
  td.heat-top{ box-shadow: inset 0 0 0 1px rgba(var(--heat-rgb), var(--heat-outline)); }

  /* Bars */
  .barwrap{height:20px;background:#0c1320;border:1px solid #26324c;border-radius:10px;overflow:hidden}
  .barfill{height:100%;background:linear-gradient(90deg, var(--brand) 0%, #ffb000 100%);}

  /* Responsive */
  @media (max-width: 980px){
    .kpis{grid-template-columns:repeat(3,1fr)}
  }
  @media (max-width: 620px){
    .kpis{grid-template-columns:repeat(2,1fr)}
    table{font-size:.9rem}
  }
</style>
</head>
<body>
<header>
  <h1>FFBR — LOPS Dashboard</h1>
  <div class="user-controls">
    <a class="btn secondary" href="dashboard.html">← Dashboard</a>
    <span class="chip" id="user-info">Checking login…</span>
    <button class="btn" id="logoutBtn">Logout</button>
  </div>
</header>

<div class="shell">

  <!-- Filters -->
  <div class="section">
    <h2>Filters</h2>
    <div class="bar">
      <label class="pill">Day
        <select id="fDay" class="input" style="min-width:140px"><option value="__all__">All</option></select>
      </label>
      <label class="pill">Match
        <select id="fMatch" class="input" style="min-width:140px"><option value="__all__">All</option></select>
      </label>
      <label class="pill">Map
        <select id="fMap" class="input" style="min-width:160px"><option value="__all__">All</option></select>
      </label>
      <input id="fTeam" class="input" placeholder="Search team…" style="min-width:180px"/>
      <input id="fPlayer" class="input" placeholder="Search player…" style="min-width:180px"/>
      <button class="btn ghost" id="clearFilters">Clear</button>
    </div>
    <div class="muted" id="scopeText">—</div>
  </div>

  <!-- KPIs -->
  <div class="section">
    <h2>Overview</h2>
    <div class="kpis" id="kpiWrap">
      <!-- populated -->
    </div>
  </div>

  <!-- TEAM LEADERBOARD -->
  <details class="accordion" open>
    <summary>Team Leaderboard</summary>
    <div class="accordion-body">
      <div class="sortbar">
        <label>Sort
          <select id="teamSortKey" class="input">
            <option value="points" selected>Points</option>
            <option value="kills">Kills</option>
            <option value="assists">Assists</option>
            <option value="booyah_rate">Booyah %</option>
            <option value="avg_place">Avg Placement</option>
            <option value="mvp">MVPs</option>
            <option value="kpm">Kills / match</option>
            <option value="ppm">Points / match</option>
            <option value="team">Team A→Z</option>
          </select>
        </label>
        <button class="btn secondary" id="teamSortDir" data-dir="desc">Desc</button>
      </div>
      <div id="tblTeams">Loading…</div>
    </div>
  </details>

  <!-- PLAYER LEADERBOARD -->
  <details class="accordion" open>
    <summary>Player Leaderboard (Top 25)</summary>
    <div class="accordion-body">
      <div class="sortbar">
        <label>Sort
          <select id="playerSortKey" class="input">
            <option value="kills" selected>Kills</option>
            <option value="assists">Assists</option>
            <option value="points">Points</option>
            <option value="kpm">Kills / match</option>
            <option value="ppm">Points / match</option>
            <option value="mvp">MVPs</option>
            <option value="player">Player A→Z</option>
          </select>
        </label>
        <button class="btn secondary" id="playerSortDir" data-dir="desc">Desc</button>
      </div>
      <div id="tblPlayers">Loading…</div>
    </div>
  </details>

  <!-- TEAM x MAP HEATMAP -->
  <details class="accordion" open>
    <summary>Team × Map Heatmap</summary>
    <div class="accordion-body">
      <div class="bar" style="margin-bottom:10px">
        <label>Metric
          <select id="heatMetric" class="input">
            <option value="ppm" selected>Points / match</option>
            <option value="kpm">Kills / match</option>
            <option value="booyah_rate">Booyah %</option>
            <option value="place_inv">Placement (better=brighter)</option>
          </select>
        </label>
      </div>
      <div id="tblHeat">Loading…</div>
    </div>
  </details>

  <!-- PICKS -->
  <details class="accordion" open>
    <summary>Pick Rates (Characters / Active Skills / Pet Skills)</summary>
    <div class="accordion-body">
      <div class="bar"><span class="muted">Counts from filtered rows</span></div>
      <div class="section" style="margin:0 0 10px">
        <h3 style="margin:0 0 8px;color:#ffd84a">Top Characters</h3>
        <div id="listChars">—</div>
      </div>
      <div class="section" style="margin:0 0 10px">
        <h3 style="margin:0 0 8px;color:#ffd84a">Active Skills</h3>
        <div id="listActive">—</div>
      </div>
      <div class="section" style="margin:0">
        <h3 style="margin:0 0 8px;color:#ffd84a">Pet Skills</h3>
        <div id="listPet">—</div>
      </div>
    </div>
  </details>

  <!-- MVP LEDGER -->
  <details class="accordion">
    <summary>MVP Ledger</summary>
    <div class="accordion-body" id="mvpLedger">
      Loading…
    </div>
  </details>

  <!-- DATA EXPLORER -->
  <details class="accordion">
    <summary>Data Explorer</summary>
    <div class="accordion-body">
      <div class="bar" style="margin-bottom:10px">
        <label>Columns
          <select id="explCols" class="input" multiple size="6" style="min-width:280px"></select>
        </label>
        <label>Limit
          <select id="explLimit" class="input">
            <option>100</option><option selected>500</option><option>1000</option><option>2000</option><option>4000</option>
          </select>
        </label>
        <button class="btn secondary" id="explRefresh">Refresh</button>
      </div>
      <div id="tblExplorer">—</div>
    </div>
  </details>

</div>

<script>
/* ===== Supabase & Auth ===== */
const client = supabase.createClient(
  'https://gkugecflfddkpitlrmws.supabase.co',
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdrdWdlY2ZsZmRka3BpdGxybXdzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDYwODMwNzQsImV4cCI6MjA2MTY1OTA3NH0.OgQOx9k71DDdK1yOa7VNKGSgoFD9kNGo8j-bR91zGKE'
);

(async () => {
  const { data: { session } } = await client.auth.getSession();
  if (!session) { window.location.href = 'index.html'; return; }
  const ui = document.getElementById('user-info');
  if (ui && session.user?.email) ui.textContent = `Logged in as: ${session.user.email}`;
})();
document.getElementById('logoutBtn').onclick = async () => {
  await client.auth.signOut(); window.location.href = 'index.html';
};

/* ===== Utils ===== */
const el = id => document.getElementById(id);
const norm = v => (v==null ? '' : String(v).trim());
const low  = v => norm(v).toLowerCase();
const n = v => {
  if (v==null) return 0;
  if (typeof v === 'number') return isFinite(v) ? v : 0;
  const s = String(v).replace(/[, ]/g,'').trim();
  const m = s.match(/^(-?\d+(\.\d+)?)$/);
  return m ? Number(m[1]) : 0;
};
const uniq = arr => Array.from(new Set(arr));
const sum = (arr,key) => arr.reduce((t,r)=>t+n(r[key]),0);
const html = s => s;
function looksLikeURL(v){ return /^https?:\/\//i.test(String(v||'')); }
function escapeHtml(s){ return s.replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }
function fmt(x,dec=0){ x=Number(x); return isFinite(x)? x.toFixed(dec) : '—'; }
function pct(x){ x=Number(x); return isFinite(x)? (x*100).toFixed(1)+'%' : '—'; }

/* ===== Data & Normalization ===== */
let RAW = [];           // all rows from ffbr_lopsdata
let VIEW = [];          // rows after filters
let ALL_COLS = [];      // column names seen
let filter = { day:'__all__', match:'__all__', map:'__all__', team:'', player:'' };

function normalizeRow(r){
  const o = {...r};

  // canonical keys
  o._team   = norm(o.TeamName ?? o.Team ?? o.team ?? o.TAG ?? o.tag);
  o._player = norm(o.Player ?? o.IGN ?? o['Player IGN'] ?? o['InGameName'] ?? o['IGName']);
  o._map    = norm(o.Map ?? o.map);
  o._day    = norm(o.Day ?? o.day ?? o['WkDay'] ?? o['D']);
  o._match  = norm(o.Match ?? o.match ?? o.Game ?? o['MatchNo']);
  o._booyah = n(o.Booyah ?? o.booyah);
  o._place  = n(o.Placement ?? o.placement ?? o['Place']);

  const rankScore = n(o.RankingScore ?? o['Ranking Score']);
  const killScore = n(o.KillingScore ?? o['Killing Score']);
  const totalScore = n(o.TotalScore ?? o['Total Score'] ?? o.Total ?? o['Total Points']);
  // Prefer explicit total, else compose
  o._points = totalScore || (rankScore + killScore);

  o._kills    = n(o['Total Kill'] ?? o.Kills ?? o.KILL ?? o.KILLING ?? o.KILLCOUNT ?? o['Kill']);
  o._assists  = n(o.Assist ?? o.Assists);
  o._mvp      = n(o.MVP ?? o['MVPs']);

  // Picks
  o._chars = [];
  for (let i=1;i<=4;i++){
    const key = ['Character '+i,'Character'+i,'Char '+i,'Char'+i].find(k=>o[k]!=null);
    if (key){ const v = norm(o[key]); if (v) o._chars.push(v); }
  }
  o._active = norm(o.SkillActive ?? o['Skill Active'] ?? o.Active);
  o._pet    = norm(o['Pet Skill Name'] ?? o['PetSkill'] ?? o['Pet']);

  // derive booyah if not present
  if (!o._booyah) o._booyah = (o._place===1) ? 1 : 0;

  // game key (for per-match rates)
  o._gkey = `${low(o._day)}|${low(o._match)}|${low(o._map)}|${low(o._team)}`;

  return o;
}

/* ===== Fetch ===== */
async function fetchAll(){
  const CHUNK=2000; let from=0; const out=[];
  for(;;){
    const { data, error } = await client.from('ffbr_lopsdata')
      .select('*')
      .order('id',{ascending:true})
      .range(from, from+CHUNK-1);
    if (error){ console.error('fetch error', error); break; }
    if (!data?.length) break;
    out.push(...data);
    from += data.length;
  }
  return out;
}

/* ===== Filters ===== */
function applyFilters(){
  const qTeam = low(filter.team);
  const qPlayer = low(filter.player);
  VIEW = RAW.filter(r=>{
    if (filter.day   !== '__all__' && low(r._day)   !== low(filter.day)) return false;
    if (filter.match !== '__all__' && low(r._match) !== low(filter.match)) return false;
    if (filter.map   !== '__all__' && low(r._map)   !== low(filter.map)) return false;
    if (qTeam && !low(r._team).includes(qTeam)) return false;
    if (qPlayer && !low(r._player).includes(qPlayer)) return false;
    return true;
  });
  el('scopeText').textContent =
    `Rows: ${VIEW.length} • Days: ${uniq(VIEW.map(r=>r._day)).length} • Matches: ${uniq(VIEW.map(r=>r._match)).length} • Teams: ${uniq(VIEW.map(r=>r._team)).length}`;
}

/* ===== KPIs ===== */
function renderKPIs(){
  const games = uniq(VIEW.map(r=> `${r._day}|${r._match}|${r._map}`)).length;
  const teams = uniq(VIEW.map(r=> r._team)).length;
  const players = uniq(VIEW.map(r=> r._player)).length;

  // Points & kills might be per player; still good for totals
  const totalPts = VIEW.reduce((t,r)=> t + n(r._points), 0);
  const totalKills = VIEW.reduce((t,r)=> t + n(r._kills), 0);

  // Booyah rate per team-game
  const byTeamGame = groupBy(VIEW, r=>r._gkey);
  let booyahGames=0, gameCount=0;
  for (const [g,list] of byTeamGame){
    gameCount++;
    const isB = list.some(x=> n(x._booyah)>0 || n(x._place)===1 );
    if (isB) booyahGames++;
  }
  const booyahRate = gameCount? (booyahGames/gameCount) : 0;

  el('kpiWrap').innerHTML = [
    ['Games', games],
    ['Teams', teams],
    ['Players', players],
    ['Total Points', totalPts],
    ['Total Kills', totalKills],
    ['Booyah Rate', pct(booyahRate)]
  ].map(([t,v])=>`
    <div class="kpi">
      <div class="t">${t}</div>
      <div class="v">${typeof v==='number'? v.toLocaleString(): v}</div>
    </div>
  `).join('');
}

/* ===== Group helpers ===== */
function groupBy(arr, keyFn){ const m=new Map(); for (const r of arr){ const k=keyFn(r); if(!m.has(k)) m.set(k,[]); m.get(k).push(r);} return m; }

/* ===== Team Leaderboard ===== */
function computeTeamTable(){
  const map = new Map(); // team -> agg
  const perTeamGames = new Map(); // team -> Set of games
  const perTeamPlace = new Map(); // team -> Map(game->min place)

  for (const r of VIEW){
    if (!r._team) continue;
    if (!map.has(r._team)) map.set(r._team, { team:r._team, points:0, kills:0, assists:0, mvp:0, booyah:0 });
    const a = map.get(r._team);
    a.points += n(r._points);
    a.kills  += n(r._kills);
    a.assists+= n(r._assists);
    a.mvp    += n(r._mvp);

    // per game
    if (!perTeamGames.has(r._team)) perTeamGames.set(r._team, new Set());
    if (!perTeamPlace.has(r._team)) perTeamPlace.set(r._team, new Map());
    perTeamGames.get(r._team).add(r._gkey);

    const gmap = perTeamPlace.get(r._team);
    const cur = gmap.get(r._gkey);
    const p = n(r._place) || (n(r._booyah)>0?1:0);
    if (!cur) gmap.set(r._gkey, p || 0);
    else gmap.set(r._gkey, Math.min(cur, p||0));

    // booyah if any row in game had booyah/place=1
    if (n(r._booyah)>0 || n(r._place)===1) a.booyah += 1; // will be corrected below not to overcount
  }

  const rows=[];
  for (const [team, agg] of map){
    const gamesSet = perTeamGames.get(team) || new Set();
    const gcount = gamesSet.size || 0;

    // Correct booyah to count unique games only
    let booyahGames = 0;
    for (const g of gamesSet){
      const minPlace = perTeamPlace.get(team)?.get(g) ?? 0;
      if (minPlace===1) booyahGames++;
    }

    // avg placement from min placement per game
    const places = Array.from(perTeamPlace.get(team)?.values() || []);
    const avgPlace = places.length ? (places.reduce((t,x)=>t+n(x),0)/places.length) : 0;

    rows.push({
      team,
      points: agg.points,
      kills: agg.kills,
      assists: agg.assists,
      mvp: agg.mvp,
      matches: gcount,
      kpm: gcount ? agg.kills/gcount : 0,
      ppm: gcount ? agg.points/gcount : 0,
      booyah_rate: gcount ? booyahGames/gcount : 0,
      avg_place: avgPlace || 0
    });
  }
  return rows;
}

function renderTeamTable(){
  const key = el('teamSortKey').value;
  const dir = el('teamSortDir').dataset.dir;
  const mult = dir==='asc' ? 1 : -1;

  const rows = computeTeamTable();
  rows.sort((a,b)=>{
    if (key==='team') return mult * a.team.localeCompare(b.team);
    return mult * ((+a[key]) - (+b[key]));
  });

  const cols = [
    {label:'Team', key:'team'},
    {label:'Matches', key:'matches', right:true},
    {label:'Points', key:'points', right:true},
    {label:'Points / m', key:'ppm', right:true, fmt:'1d'},
    {label:'Kills', key:'kills', right:true},
    {label:'Kills / m', key:'kpm', right:true, fmt:'1d'},
    {label:'Assists', key:'assists', right:true},
    {label:'Booyah %', key:'booyah_rate', right:true, fmt:'pct'},
    {label:'Avg Place', key:'avg_place', right:true, fmt:'1d'},
    {label:'MVPs', key:'mvp', right:true},
  ];

  el('tblTeams').innerHTML = renderTable(rows, cols);
}

/* ===== Player Leaderboard ===== */
function computePlayerTable(){
  const map = new Map(); // player -> agg
  const gamesByPlayer = new Map(); // player -> Set game keys (team-insensitive per player)
  for (const r of VIEW){
    if (!r._player) continue;
    if (!map.has(r._player)) map.set(r._player, { player:r._player, team: r._team, points:0, kills:0, assists:0, mvp:0 });
    const a = map.get(r._player);
    a.points += n(r._points);
    a.kills  += n(r._kills);
    a.assists+= n(r._assists);
    a.mvp    += n(r._mvp);
    if (!gamesByPlayer.has(r._player)) gamesByPlayer.set(r._player, new Set());
    // group by day|match|map for that player
    gamesByPlayer.get(r._player).add(`${low(r._day)}|${low(r._match)}|${low(r._map)}`);
  }
  const out=[];
  for (const [player, agg] of map){
    const matches = gamesByPlayer.get(player)?.size || 0;
    out.push({
      player, team: agg.team,
      kills: agg.kills,
      assists: agg.assists,
      points: agg.points,
      kpm: matches? agg.kills/matches : 0,
      ppm: matches? agg.points/matches : 0,
      mvp: agg.mvp,
      matches
    });
  }
  return out;
}

function renderPlayerTable(){
  const key = el('playerSortKey').value;
  const dir = el('playerSortDir').dataset.dir;
  const mult = dir==='asc' ? 1 : -1;

  const rows = computePlayerTable();
  rows.sort((a,b)=>{
    if (key==='player') return mult * a.player.localeCompare(b.player);
    return mult * ((+a[key]) - (+b[key]));
  });

  const top = rows.slice(0,25);
  const cols = [
    {label:'Player', key:'player'},
    {label:'Team', key:'team'},
    {label:'Matches', key:'matches', right:true},
    {label:'Points', key:'points', right:true},
    {label:'Points / m', key:'ppm', right:true, fmt:'1d'},
    {label:'Kills', key:'kills', right:true},
    {label:'Kills / m', key:'kpm', right:true, fmt:'1d'},
    {label:'Assists', key:'assists', right:true},
    {label:'MVPs', key:'mvp', right:true},
  ];
  el('tblPlayers').innerHTML = renderTable(top, cols);
}

/* ===== Heatmap (Team × Map) ===== */
function computeHeatCube(){
  const byTeamMap = new Map(); // `${team}||${map}` -> agg
  const teamSet = new Set(), mapSet = new Set();
  const gamesSeen = new Map(); // key -> Set of game keys per team-map

  for (const r of VIEW){
    const team = r._team||''; const map = r._map||'';
    if (!team||!map) continue;
    const key = team+'||'+map;
    if (!byTeamMap.has(key)) byTeamMap.set(key, {team,map, points:0, kills:0, booyahGames:0, totalGames:0, placeSum:0, placeN:0});
    teamSet.add(team); mapSet.add(map);

    // track unique games per team-map
    const gk = `${low(r._day)}|${low(r._match)}|${low(r._map)}|${low(r._team)}`;
    if (!gamesSeen.has(key)) gamesSeen.set(key, new Set());
    const set = gamesSeen.get(key);
    const firstTime = !set.has(gk);
    if (firstTime){
      set.add(gk);
      byTeamMap.get(key).totalGames += 1;
      // booyah check per game
      const booy = (n(r._booyah)>0 || n(r._place)===1) ? 1 : 0;
      byTeamMap.get(key).booyahGames += booy;
    }

    byTeamMap.get(key).points += n(r._points);
    byTeamMap.get(key).kills  += n(r._kills);

    // placement — keep min per game by writing min as we go (approx via per-row min)
    const p = n(r._place) || (n(r._booyah)>0?1:0);
    if (p>0){
      // average of mins across rows is approximated by using the minimum encountered per team-map game,
      // but since we're not tracking per game min separately here, we approximate with simple aggregate.
      byTeamMap.get(key).placeSum += p;
      byTeamMap.get(key).placeN += 1;
    }
  }

  const teams = Array.from(teamSet).sort((a,b)=>a.localeCompare(b));
  const maps = Array.from(mapSet).sort((a,b)=>a.localeCompare(b));

  // build rows for table with chosen metric computed later
  const grid = teams.map(team=>{
    const row = { team };
    for (const m of maps){
      const key = team+'||'+m;
      const o = byTeamMap.get(key);
      if (!o || !o.totalGames){
        row[m] = {disp:'—', v:null};
      } else {
        const ppm = o.points / o.totalGames;
        const kpm = o.kills / o.totalGames;
        const br  = o.booyahGames / o.totalGames;
        const placeAvg = o.placeN? (o.placeSum/o.placeN) : null;
        const placeInv = placeAvg? (1/Math.max(1e-6, placeAvg)) : null;
        row[m] = { ppm, kpm, booyah_rate: br, place_avg: placeAvg, place_inv: placeInv };
      }
    }
    return row;
  });

  return { teams, maps, grid };
}

function renderHeatmap(){
  const metric = el('heatMetric').value; // ppm | kpm | booyah_rate | place_inv

  const {teams, maps, grid} = computeHeatCube();
  if (!teams.length || !maps.length){
    el('tblHeat').innerHTML = '<div class="muted">No data for heatmap.</div>'; return;
  }

  // Prepare numeric series for quantiles
  const values = [];
  for (const row of grid){
    for (const m of maps){
      const cell = row[m];
      const v = cell?.[metric];
      if (v!=null && isFinite(v)) values.push(v);
    }
  }

  // Render table
  let thead = `<thead><tr><th>Team</th>${maps.map(m=>`<th class="right">${escapeHtml(m)}</th>`).join('')}</tr></thead>`;
  let tbody = '<tbody>' + grid.map(row=>{
    const tds = maps.map(m=>{
      const cell = row[m] || {};
      let v = cell?.[metric];
      let disp = '—';
      if (v!=null && isFinite(v)){
        if (metric==='booyah_rate') disp = pct(v);
        else if (metric==='place_inv') disp = cell.place_avg ? (1/cell.place_inv).toFixed(1) : '—'; // show Avg Place
        else disp = v.toFixed(1);
      }
      return `<td data-key="${metric}" class="right">${disp}</td>`;
    }).join('');
    return `<tr><td>${escapeHtml(row.team)}</td>${tds}</tr>`;
  }).join('') + '</tbody>';

  el('tblHeat').innerHTML = `<table>${thead}${tbody}</table>`;

  // Apply quantile-band coloring
  applyQuantileHeat('tblHeat', [metric], 5, metric==='place_inv'); // invert already done by using place_inv (higher better)
}

/* Quantile-band heat (rounded, on-brand) */
function applyQuantileHeat(containerId, keys, bands=5, alreadyInverted=false){
  const wrap = el(containerId);
  const table = wrap?.querySelector('table'); if (!table) return;

  table.querySelectorAll('td[data-key]').forEach(td=>{
    td.style.backgroundColor=''; td.classList.remove('heat-top');
  });

  const styles = getComputedStyle(document.documentElement);
  const rgb   = styles.getPropertyValue('--heat-rgb') || '255,233,59';
  const minA  = parseFloat(styles.getPropertyValue('--heat-min')) || .06;
  const maxA  = parseFloat(styles.getPropertyValue('--heat-max')) || .24;
  const radius= styles.getPropertyValue('--heat-radius') || '8px';

  for (const key of keys){
    const cells = Array.from(table.querySelectorAll(`td[data-key="${key}"]`));
    const entries = cells.map((td,i)=>{
      const raw = (td.textContent||'').trim().replace('%','').replace(/,/g,'');
      let v = parseFloat(raw);
      if (key==='place_inv'){ // we displayed Avg Place; recompute from title? Instead derive from text:
        // If text shows Avg Place (e.g., 2.1), invert here:
        if (!alreadyInverted){
          v = isFinite(v) ? (1/Math.max(1e-6,v)) : NaN;
        }
      }
      return { td, i, v: isFinite(v) ? v : null };
    }).filter(e=>e.v!=null);

    if (!entries.length) continue;
    // sort asc for banding
    const asc = entries.slice().sort((a,b)=> a.v - b.v);
    const n = asc.length;
    const topVal = asc[n-1].v;

    // band map
    const bandByIndex = new Map();
    asc.forEach((e, rank)=>{
      const p = n<=1 ? 1 : (rank/(n-1));
      const band = Math.min(bands-1, Math.floor(p*bands)); // 0..bands-1
      bandByIndex.set(e.i, band);
    });

    // paint
    cells.forEach((td,i)=>{
      const band = bandByIndex.get(i);
      if (band==null) return;
      const alpha = minA + (band/(bands-1))*(maxA - minA);
      td.style.backgroundColor = `rgba(${rgb}, ${alpha.toFixed(3)})`;
      td.style.borderRadius = radius;
      td.style.backgroundClip = 'padding-box';

      const val = asc[n-1].v;
      const here = entries.find(e=>e.td===td)?.v;
      if (here!=null && here===val) td.classList.add('heat-top');
    });
  }
}

/* ===== Picks ===== */
function tally(items){
  const m=new Map();
  for(const v of items){ const k=norm(v); if(!k) continue; m.set(k,(m.get(k)||0)+1); }
  return Array.from(m.entries()).map(([name,count])=>({name,count})).sort((a,b)=> b.count-a.count || a.name.localeCompare(b.name));
}
function renderBars(list, mountId, maxItems=20){
  if (!list.length){ el(mountId).innerHTML = '<div class="muted">No data.</div>'; return; }
  const total = list.reduce((t,x)=>t+x.count,0);
  const top = list.slice(0, maxItems);
  el(mountId).innerHTML = top.map(x=>{
    const frac = total? (x.count/total) : 0;
    return `
      <div style="display:grid;grid-template-columns:200px 1fr 60px;gap:10px;align-items:center;margin:6px 0">
        <div>${escapeHtml(x.name)}</div>
        <div class="barwrap"><div class="barfill" style="width:${(frac*100).toFixed(1)}%"></div></div>
        <div class="right">${x.count}</div>
      </div>
    `;
  }).join('');
}
function renderPicks(){
  const chars = VIEW.flatMap(r=> r._chars||[]);
  const act   = VIEW.map(r=> r._active).filter(Boolean);
  const pet   = VIEW.map(r=> r._pet).filter(Boolean);

  renderBars(tally(chars), 'listChars');
  renderBars(tally(act), 'listActive');
  renderBars(tally(pet), 'listPet');
}

/* ===== MVP Ledger ===== */
function renderMVP(){
  // group by Day -> Match -> rows where MVP>0 (or highest kills/points?)
  const byDay = groupBy(VIEW, r=> r._day || '—');
  if (!byDay.size){ el('mvpLedger').innerHTML = '<div class="muted">No data.</div>'; return; }

  let htmlOut = '';
  const days = Array.from(byDay.keys()).sort((a,b)=> a.localeCompare(b,undefined,{numeric:true}));
  for (const d of days){
    const byMatch = groupBy(byDay.get(d), r=> r._match || '—');
    htmlOut += `<div class="section" style="margin:0 0 10px"><h3 style="margin:0 0 8px;color:#ffd84a">Day ${escapeHtml(d)}</h3>`;
    const matches = Array.from(byMatch.keys()).sort((a,b)=> a.localeCompare(b,undefined,{numeric:true}));
    htmlOut += '<div>';
    for (const m of matches){
      const list = byMatch.get(m);
      // choose MVP rows: either explicit MVP>0 else best (kills then points)
      let mvps = list.filter(x=> n(x._mvp)>0 );
      if (!mvps.length){
        const bestKill = Math.max(...list.map(x=>n(x._kills)));
        mvps = list.filter(x=> n(x._kills)===bestKill);
        if (mvps.length>3){
          const bestPts = Math.max(...list.map(x=>n(x._points)));
          mvps = list.filter(x=> n(x._points)===bestPts);
        }
      }
      const items = mvps.slice(0,3).map(x=> `${escapeHtml(x._player||'—')} <span class="muted">(${n(x._kills)}K • ${n(x._points)}pts)</span>`).join(', ');
      htmlOut += `<div style="margin:4px 0"><span class="pill">Match ${escapeHtml(m)}</span> — ${items||'<span class="muted">No MVP data</span>'}</div>`;
    }
    htmlOut += '</div></div>';
  }
  el('mvpLedger').innerHTML = htmlOut;
}

/* ===== Explorer ===== */
function renderExplorer(){
  const sel = el('explCols');
  const limit = Number(el('explLimit').value)||500;
  const cols = Array.from(sel.selectedOptions).map(o=>o.value);
  const rows = VIEW.slice(0, limit).map(r=>{
    const obj={}; for (const c of cols){ obj[c] = r[c]; } return obj;
  });
  el('tblExplorer').innerHTML = renderTable(rows, cols.map(c=>({label:c,key:c})));
}

/* ===== Generic table renderer ===== */
function renderTable(list, cols){
  if (!list.length) return '<div class="muted">No rows.</div>';
  const head = `<thead><tr>${cols.map(c=>`<th class="${c.right?'right':''}">${c.label}</th>`).join('')}</tr></thead>`;
  const body = '<tbody>' + list.map(r=>{
    const tds = cols.map(c=>{
      let v = r[c.key];
      if (c.fmt==='pct') v = pct(v);
      else if (c.fmt==='1d') v = isFinite(v)? Number(v).toFixed(1) : '—';
      else if (c.fmt==='2d') v = isFinite(v)? Number(v).toFixed(2) : '—';
      else if (v==null || v==='') v = '—';
      return `<td class="${c.right?'right':''}" data-key="${c.key}">${escapeHtml(String(v))}</td>`;
    }).join('');
    return `<tr>${tds}</tr>`;
  }).join('') + '</tbody>';
  return `<table>${head}${body}</table>`;
}

/* ===== Populate filter options ===== */
function populateFilters(){
  const days   = ['__all__'].concat(uniq(RAW.map(r=>r._day)).sort((a,b)=>a.localeCompare(b,undefined,{numeric:true})).filter(Boolean));
  const matches= ['__all__'].concat(uniq(RAW.map(r=>r._match)).sort((a,b)=>a.localeCompare(b,undefined,{numeric:true})).filter(Boolean));
  const maps   = ['__all__'].concat(uniq(RAW.map(r=>r._map)).sort((a,b)=>a.localeCompare(b)).filter(Boolean));

  el('fDay').innerHTML    = days.map(v=> `<option value="${escapeHtml(v)}">${v==='__all__'?'All':escapeHtml(v)}</option>`).join('');
  el('fMatch').innerHTML  = matches.map(v=> `<option value="${escapeHtml(v)}">${v==='__all__'?'All':escapeHtml(v)}</option>`).join('');
  el('fMap').innerHTML    = maps.map(v=> `<option value="${escapeHtml(v)}">${v==='__all__'?'All':escapeHtml(v)}</option>`).join('');
}

/* ===== Wire UI ===== */
function wireUI(){
  el('fDay').addEventListener('change', e=>{ filter.day=e.target.value; refreshAll(); });
  el('fMatch').addEventListener('change', e=>{ filter.match=e.target.value; refreshAll(); });
  el('fMap').addEventListener('change', e=>{ filter.map=e.target.value; refreshAll(); });
  el('fTeam').addEventListener('input', e=>{ filter.team=e.target.value; refreshAll(); });
  el('fPlayer').addEventListener('input', e=>{ filter.player=e.target.value; refreshAll(); });
  el('clearFilters').onclick = ()=>{
    filter={ day:'__all__', match:'__all__', map:'__all__', team:'', player:'' };
    populateFilters();
    el('fTeam').value=''; el('fPlayer').value='';
    refreshAll();
  };

  el('teamSortKey').addEventListener('change', renderTeamTable);
  el('teamSortDir').onclick = ()=>{
    const b=el('teamSortDir'); b.dataset.dir = (b.dataset.dir==='desc'?'asc':'desc'); b.textContent = b.dataset.dir==='desc'?'Desc':'Asc';
    renderTeamTable();
  };

  el('playerSortKey').addEventListener('change', renderPlayerTable);
  el('playerSortDir').onclick = ()=>{
    const b=el('playerSortDir'); b.dataset.dir = (b.dataset.dir==='desc'?'asc':'desc'); b.textContent = b.dataset.dir==='desc'?'Desc':'Asc';
    renderPlayerTable();
  };

  el('heatMetric').addEventListener('change', renderHeatmap);

  el('explRefresh').onclick = renderExplorer;
}

/* ===== Refresh pipeline ===== */
function refreshAll(){
  applyFilters();
  renderKPIs();
  renderTeamTable();
  renderPlayerTable();
  renderHeatmap();
  renderPicks();
  renderMVP();
  // Explorer keeps its own selection; only redraw if already populated
  if (el('explCols').options.length) renderExplorer();
}

/* ===== Init ===== */
async function init(){
  const raw = await fetchAll();
  RAW = raw.map(normalizeRow);
  ALL_COLS = uniq(RAW.flatMap(r=>Object.keys(r)));

  // Fill explorer column chooser
  const expl = el('explCols');
  const defaultCols = ['_day','_match','_map','_team','_player','_points','_kills','_assists','_place','_booyah','_active','_pet'];
  const items = uniq(defaultCols.concat(ALL_COLS)).filter(c=>!/^_gkey$/.test(c));
  expl.innerHTML = items.map(c=> `<option value="${escapeHtml(c)}" ${defaultCols.includes(c)?'selected':''}>${escapeHtml(c)}</option>`).join('');

  populateFilters();
  wireUI();
  refreshAll();
}

init();
</script>
</body>
</html>
