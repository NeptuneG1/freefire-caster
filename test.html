<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Clash Squad — Team Compare</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    :root{
      --bg:#0e0e0e; --panel:#1b1b1b; --panel2:#141414;
      --ink:#f5f5f5; --muted:#b9b9b9; --brand:#ffbd59; --brand2:#ff7733;
      --line:#313131; --good:#71d083; --bad:#ff6b6b;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Ubuntu,Arial,sans-serif}
    header{position:sticky;top:0;z-index:5;background:#1f1f1f;border-bottom:3px solid var(--brand);padding:14px 16px}
    h1{margin:0;font-size:1.1rem;letter-spacing:.3px;color:var(--brand)}
    .user-controls{position:absolute;right:16px;top:12px;display:flex;gap:10px;align-items:center}
    .chip{font-size:.85rem;color:#ddd}
    .btn{background:var(--brand);color:var(--panel);border:0;border-radius:8px;padding:8px 12px;font-weight:700;cursor:pointer;text-decoration:none;display:inline-block}
    .btn:hover{background:#e6a74f}
    .shell{max-width:1200px;margin:22px auto;padding:0 12px}

    .bar{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-bottom:12px}
    .controls{display:flex;flex-wrap:wrap;gap:8px}
    .controls label{display:flex;align-items:center;gap:6px;background:var(--panel2);border:1px solid var(--line);padding:6px 8px;border-radius:8px}
    .controls select,.controls input[type="date"],.controls input[type="number"]{background:#212121;color:var(--brand);border:1px solid #3a3a3a;border-radius:6px;padding:6px 8px}
    .muted{color:var(--muted);font-size:.9rem}

    .section{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px;margin-bottom:14px}
    .section h2{margin:0 0 10px;color:var(--brand)}
    .grid2{display:grid;grid-template-columns:repeat(2,minmax(320px,1fr));gap:12px}
    .card{background:var(--panel2);border:1px solid var(--line);border-radius:12px;padding:10px}
    .card h3{margin:0 0 6px;color:var(--brand2);font-size:1.0rem}
    .kpis{display:flex;gap:6px;flex-wrap:wrap;margin:6px 0}
    .kpi{background:#111;border:1px solid #2a2a2a;border-radius:8px;padding:5px 8px;font-size:.9rem}

    table{width:100%;border-collapse:collapse;font-size:.92rem}
    th,td{border-bottom:1px solid #2a2a2a;padding:6px 6px;vertical-align:top}
    thead th{background:#191919;text-align:left;position:sticky;top:0}
    .right{text-align:right}
    .mono{font-variant-numeric:tabular-nums}
    .icons{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
    .icons img{width:22px;height:22px;border-radius:5px;border:1px solid #333;background:#111;object-fit:cover}
    .wl{font-weight:700;padding:2px 8px;border-radius:999px;display:inline-block}
    .wl.W{background:#193e2b;color:var(--good);border:1px solid #245b3e}
    .wl.L{background:#401e1e;color:var(--bad);border:1px solid #6b2c2c}
    .caption{margin:4px 0 8px}
    .tight{line-height:1.25}

    .delta-pos{color:var(--good);font-weight:700}
    .delta-neg{color:var(--bad);font-weight:700}
    .opp-logos{display:inline-flex;gap:4px;align-items:center;margin-left:6px;vertical-align:middle}
    .opp-logos img{width:18px;height:18px;border-radius:4px;border:1px solid #333;background:#111;object-fit:cover}
    .opp-logos .logo-wrap{position:relative;display:inline-block}
    .opp-logos .cnt{position:absolute;right:-6px;bottom:-6px;background:#171717;border:1px solid #333;border-radius:6px;padding:0 3px;font-size:10px;line-height:1.2;color:#ccc;}

    details.accordion{background:var(--panel);border:1px solid var(--line);border-radius:12px;margin-bottom:14px;overflow:hidden;}
    details.accordion > summary{list-style:none;cursor:pointer;padding:12px 14px;color:var(--brand);font-weight:800;background:linear-gradient(180deg,#1b1b1b 0%, #171717 100%);user-select:none;outline:none;display:flex;align-items:center;gap:8px;border-bottom:1px solid var(--line);}
    details.accordion > summary::-webkit-details-marker{display:none}
    details.accordion > summary::after{content:'▾';margin-left:auto;transition:transform .18s ease;opacity:.9;}
    details.accordion[open] > summary::after{ transform:rotate(-180deg); }
    details.accordion .accordion-body{ padding:12px; }

    /* ========= Matches table: force Players to own the space ========= */
    .mTable{width:100%;table-layout:fixed;border-collapse:separate;border-spacing:0}
    .mTable th,.mTable td{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .mTable td.last, .mTable th.last{white-space:normal;overflow:visible;text-overflow:unset}

    /* ========= Player tiles: tighter + adaptive ========= */
    .playersWrap{
      display:grid;
      grid-template-columns:repeat(2, minmax(0, 1fr)); /* default 2-up */
      gap:6px;
      width:100%;
      min-width:0;
    }
    @media (min-width:1400px){
      .playersWrap{ grid-template-columns:repeat(3, minmax(0, 1fr)); } /* allow 3-up on very wide screens */
    }
    @media (max-width:860px){
      .playersWrap{ grid-template-columns:1fr; } /* phone: 1-up */
    }

    .pTile{
      position:relative;
      aspect-ratio:5/4;               /* flatter than 1:1 to save height */
      border-radius:12px;
      background:#141414;
      border:1px solid #2a2a2a;
      overflow:hidden;
      box-shadow:0 0 0 1px #000 inset;
    }
    .pActFill{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;filter:saturate(.95) brightness(.95)}
    .pNameTag{
      position:absolute;left:6px;right:6px;top:6px;
      padding:2px 6px;font-weight:700;font-size:11px;line-height:1.1;
      color:#f2f2f2;background:rgba(0,0,0,.55);border:1px solid #333;border-radius:7px;
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
    }
    .pHeroTag{
      position:absolute;left:6px;right:6px;top:24px;
      padding:2px 6px;font-size:10px;line-height:1.1;color:#d8d8d8;
      background:rgba(0,0,0,.42);border:1px solid #2e2e2e;border-radius:6px;
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
    }
    .pPassiveBar{
      position:absolute;left:6px;right:6px;bottom:6px;
      display:flex;justify-content:center;gap:6px;
      padding:2px 4px;background:rgba(0,0,0,.55);border:1px solid #333;border-radius:8px;
    }
    .pPassiveBar img{ width:14px;height:14px;object-fit:cover;border-radius:3px;border:1px solid #333;background:#0f0f0f }

    /* Auto-compact when narrow: hide labels; shrink passives more in "micro" */
    .playersWrap.mini .pNameTag,.playersWrap.mini .pHeroTag{display:none}
    .playersWrap.mini .pPassiveBar img{ width:13px;height:13px }
    .playersWrap.micro .pPassiveBar img{ width:12px;height:12px }
    .playersWrap.micro .pTile{ border-radius:10px }
    @media (max-width: 860px){ .grid2{grid-template-columns:1fr} }
  </style>
</head>
<body>
<header>
  <h1>Clash Squad — Team Compare</h1>
  <div class="user-controls">
    <span class="chip" id="user-info">Checking login…</span>
    <button class="btn" id="logoutBtn">Logout</button>
  </div>
</header>

<div class="shell">

  <div class="bar">
    <a class="btn" href="dashboard.html">← Back to Dashboard</a>
    <div class="controls" style="margin-left:auto">
      <label>From <input type="date" id="fFrom"></label>
      <label>To <input type="date" id="fTo"></label>
      <label>Map
        <select id="fMap">
          <option value="__ALL__">All maps</option>
          <option value="Bermuda">Bermuda</option><option value="Kalahari">Kalahari</option>
          <option value="Purgatory">Purgatory</option><option value="Alpine">Alpine</option>
          <option value="Nexterra">Nexterra</option><option value="Solara">Solara</option>
        </select>
      </label>
      <label>Tournament <select id="fTourn"></select></label>
      <label>Outcome
        <select id="fWL">
          <option value="__ALL__">All</option>
          <option value="W">Wins only</option>
          <option value="L">Losses only</option>
        </select>
      </label>
      <button class="btn" id="applyBtn">Apply</button>
    </div>
  </div>

  <details class="accordion" open>
    <summary>Pick two teams</summary>
    <div class="accordion-body">
      <div class="controls">
        <label>Team A <select id="cmpTeamA"></select></label>
        <label>Team B <select id="cmpTeamB"></select></label>
        <button class="btn" id="cmpSwap" title="Swap A/B">Swap</button>
      </div>
      <div class="caption muted" id="meta">—</div>
    </div>
  </details>

  <div class="section">
    <h2>Overview KPIs</h2>
    <div class="grid2">
      <div class="card" id="kpiA"><h3>A</h3>Loading…</div>
      <div class="card" id="kpiB"><h3>B</h3>Loading…</div>
    </div>
  </div>

  <!-- … other accordions unchanged … -->

  <details class="accordion">
    <summary>Matches (Active + 3×Passive per player)</summary>
    <div class="accordion-body">
      <div class="grid2">
        <div class="card"><h3 id="labelMatchesA">Team A</h3><div id="matchesA">Loading…</div></div>
        <div class="card"><h3 id="labelMatchesB">Team B</h3><div id="matchesB">Loading…</div></div>
      </div>
      <div class="caption muted tight">If space gets tight, labels auto-hide and icons shrink; the grid stacks 2×2 → 1×4 on phones (and 3-wide on very large screens).</div>
    </div>
  </details>

</div>

<script>
/* ========= Supabase init + auth ========= */
const client = supabase.createClient(
  'https://gkugecflfddkpitlrmws.supabase.co',
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdrdWdlY2ZsZmRka3BpdGxybXdzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDYwODMwNzQsImV4cCI6MjA2MTY1OTA3NH0.OgQOx9k71DDdK1yOa7VNKGSgoFD9kNGo8j-bR91zGKE'
);

(async () => {
  const { data: { session } } = await client.auth.getSession();
  if (!session) { window.location.href = "index.html"; return; }
  const ui = document.getElementById('user-info');
  if (ui && session.user?.email) ui.textContent = `Logged in as: ${session.user.email}`;
})();
document.getElementById('logoutBtn').onclick = async () => {
  await client.auth.signOut();
  window.location.href = "index.html";
};

/* ========= Utilities ========= */
const PLACEHOLDER = 'https://imgur.com/AdvPwAO.png';
const el = (id) => document.getElementById(id);
const fmtPct = (x) => isFinite(x) ? (x*100).toFixed(1)+'%' : '—';
const pct = (num, den) => den ? fmtPct(num/den) : '—';
function ymd(d){ const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), da=String(d.getDate()).padStart(2,'0'); return `${y}-${m}-${da}`; }
function parseState(val){ if (!val) return {}; if (typeof val==='object') return val; try { return JSON.parse(val); } catch(e){ return {}; } }
function safe(s){ return String(s??'').replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c])); }

/* ========= Filters init ========= */
(function initFilters(){
  const today = new Date(); const from = new Date(today); from.setDate(from.getDate()-30);
  el('fFrom').value = ymd(from); el('fTo').value = ymd(today);
  el('fMap').value='__ALL__'; el('fWL').value='__ALL__';
  el('fTourn').innerHTML = `<option value="__ALL__">All tournaments</option>`;
})();

/* ========= State ========= */
let RAW_RECORDS = [];
let FIRST_LOAD_TOURN = true;

/* ========= Fetch ========= */
async function fetchRecords(){
  const from  = el('fFrom').value;
  const toRaw = el('fTo').value;
  const map   = el('fMap').value;
  const tourn = el('fTourn').value || '__ALL__';

  let q = client
    .from('draft_records')
    .select('id, match_date, game_number, team_left, team_right, team_left_score, team_right_score, map, tournament_name, state')
    .gte('match_date', from);

  if (toRaw){
    const d = new Date(toRaw); d.setDate(d.getDate()+1);
    q = q.lt('match_date', ymd(d));
  }
  if (map!=='__ALL__') q = q.eq('map', map);
  if (tourn!=='__ALL__') q = q.eq('tournament_name', tourn);

  q = q.order('match_date', { ascending:false }).order('id', { ascending:false });

  const { data, error } = await q;
  if (error){ console.error(error); alert('Failed to load records: '+error.message); return []; }
  return data || [];
}

async function populateTournamentDropdown(records){
  const dd = el('fTourn'); const prior = dd.value || '__ALL__';
  const tourns = new Set(); let latest=null;
  records.forEach(r => {
    const tn = r.tournament_name; if (!tn) return;
    tourns.add(tn);
    if (!latest || (String(r.match_date) > String(latest?.date))) latest = { name: tn, date: r.match_date };
  });
  dd.innerHTML = `<option value="__ALL__">All tournaments</option>` + [...tourns].sort().map(t=>`<option value="${t}">${t}</option>`).join('');
  if (FIRST_LOAD_TOURN && latest && (prior==='__ALL__' || !prior)){ dd.value = latest.name; FIRST_LOAD_TOURN=false; } else { dd.value = prior; }
}

/* ========= Transform ========= */
function explodeRecordToRows(rec){
  const s = parseState(rec.state);
  const picks    = Array.isArray(s.picks)       ? s.picks       : [];
  const passives = Array.isArray(s.passives)    ? s.passives    : [];
  const bans     = Array.isArray(s.bans)        ? s.bans        : [];
  const names    = Array.isArray(s.playerCards) ? s.playerCards : [];

  const leftWin  = (rec.team_left_score ?? 0) > (rec.team_right_score ?? 0);
  const rightWin = (rec.team_right_score ?? 0) > (rec.team_left_score ?? 0);

  function sideRow(side){
    const isL = side==='L';
    const team = isL ? rec.team_left : rec.team_right;
    const opp  = isL ? rec.team_right : rec.team_left;
    const ts   = isL ? (rec.team_left_score ?? 0) : (rec.team_right_score ?? 0);
    const os   = isL ? (rec.team_right_score ?? 0) : (rec.team_left_score ?? 0);
    const res  = (isL ? leftWin : rightWin) ? 'W' : 'L';
    const banObj = bans[ isL ? 0 : 1 ] || {};
    const ban    = banObj?.name || '';
    const banImg = banObj?.image_url || PLACEHOLDER;

    const idx = isL ? [0,1,2,3] : [7,6,5,4];
    const actives = idx.map((i,k)=>{
      const player = (names[i] && String(names[i]).trim()) ? names[i].trim() : `P${k+1}`;
      const heroObj = (picks[i] && typeof picks[i]==='object') ? picks[i] : null;
      return { player, hero: heroObj?.name || '', heroImg: heroObj?.image_url || PLACEHOLDER };
    });
    const passiveLines = idx.map((i,k)=>{
      const player = (names[i] && String(names[i]).trim()) ? names[i].trim() : `P${k+1}`;
      const trioRaw = Array.isArray(passives[i]) ? passives[i] : [];
      const trioObjs = trioRaw.filter(Boolean).map(ps=>({name: ps?.name || '', img: ps?.image_url || PLACEHOLDER}));
      while (trioObjs.length<3) trioObjs.push({name:'', img: PLACEHOLDER});
      return { player, trio: trioObjs.slice(0,3) };
    });

    return {
      rec_id:rec.id,
      tournament: rec.tournament_name || '—',
      match_date:rec.match_date,
      game_number:rec.game_number ?? 0,
      map:rec.map,
      team, opponent:opp, team_score:ts, opp_score:os, result:res,
      banName:ban, banImg,
      actives, passives:passiveLines
    };
  }
  return [sideRow('L'), sideRow('R')];
}

function applyWL(rows){
  const wl = el('fWL').value;
  if (wl==='__ALL__') return rows;
  return rows.filter(r => r.result === wl);
}

function rowsForTeam(team){
  const rows = RAW_RECORDS.flatMap(explodeRecordToRows).filter(r=>r.team===team);
  return applyWL(rows);
}

/* ========= Matches UI ========= */
function renderPlayerCard(active, trio){
  const t = (trio||[]).slice(0,3);
  const pName = safe(active.player||'');
  const hName = safe(active.hero||'');
  const actSrc = active.heroImg || PLACEHOLDER;
  const icon = (ps)=>`<img src="${ps?.img||PLACEHOLDER}" title="${safe(ps?.name||'')}" alt="">`;
  return `
    <div class="pTile" title="${pName}${hName?(' — '+hName):''}">
      <img class="pActFill" src="${actSrc}" alt="${hName}">
      <div class="pNameTag">${pName}</div>
      <div class="pHeroTag">${hName}</div>
      <div class="pPassiveBar">
        ${icon(t[0]||{})}${icon(t[1]||{})}${icon(t[2]||{})}
      </div>
    </div>`;
}
function renderPlayersGrid(row){
  const cards = row.actives.map((a, i)=> renderPlayerCard(a, (row.passives[i]||{}).trio||[])).join('');
  return `<div class="playersWrap">${cards}</div>`;
}
function matchesTable(rows){
  if(!rows.length) return `<div class="muted">No matches for selection.</div>`;
  const sorted = [...rows].sort((a,b)=>{
    const da = new Date(a.match_date), db = new Date(b.match_date);
    return db - da || (a.game_number||0) - (b.game_number||0) || a.rec_id - b.rec_id;
  });
  return `
    <table class="mTable">
      <colgroup>
        <col style="width:76px"><!-- Date -->
        <col style="width:64px"><!-- Game -->
        <col style="width:88px"><!-- Map -->
        <col style="width:136px"><!-- Team -->
        <col style="width:136px"><!-- Opponent -->
        <col style="width:68px"><!-- Score -->
        <col style="width:70px"><!-- Result -->
        <col style="width:132px"><!-- Ban -->
        <col><!-- Players (fills remaining) -->
      </colgroup>
      <thead>
        <tr>
          <th>Dat</th><th>Gam</th><th>Map</th><th>Team</th><th>Opp</th>
          <th class="right">Sco</th><th class="right">Res</th><th>Ban</th><th class="last">Players</th>
        </tr>
      </thead>
      <tbody>
        ${sorted.map(r=>{
          const score = `${r.team_score} - ${r.opp_score}`;
          const g = r.game_number ? `Game ${r.game_number}` : '—';
          return `
            <tr>
              <td class="mono">${String(r.match_date||'').slice(0,10)}</td>
              <td>${g}</td>
              <td>${r.map||'—'}</td>
              <td>${r.team||'—'}<div class="muted tight">vs ${r.opponent||'—'}</div></td>
              <td>${r.opponent||'—'}</td>
              <td class="right mono">${score}</td>
              <td class="right"><span class="wl ${r.result}">${r.result}</span></td>
              <td>
                <div class="icons">
                  <img src="${r.banImg||PLACEHOLDER}" alt="${r.banName||''}" title="${r.banName||''}">
                  <span class="muted tight">${r.banName||'—'}</span>
                </div>
              </td>
              <td class="last">${renderPlayersGrid(r)}</td>
            </tr>`;
        }).join('')}
      </tbody>
    </table>`;
}

/* Adapt players grid density based on available width */
function adaptPlayersWrap(){
  document.querySelectorAll('.playersWrap').forEach(w=>{
    const width = w.clientWidth || 0;
    const colCount = getComputedStyle(w).gridTemplateColumns.split(' ').filter(Boolean).length || 1;
    const approx = width / colCount;
    w.classList.toggle('mini', approx < 130);   // hide labels
    w.classList.toggle('micro', approx < 105);  // shrink icons further
  });
}

/* ========= KPIs card (kept) ========= */
function buildTeamBucket(rows, teamName, kind){
  const B = { name: teamName, matches:0, wins:0, skills:new Map() };
  rows.forEach(r=>{
    B.matches += 1; if (r.result==='W') B.wins += 1;
    if (kind==='active'){
      r.actives.forEach(a=>{
        const nm = a.hero; if (!nm) return;
        const S = B.skills.get(nm) || { occ:0, appear:0, appearWins:0 };
        S.occ += 1; S.appear += 1; if (r.result==='W') S.appearWins += 1;
        B.skills.set(nm, S);
      });
    } else if (kind==='passive'){
      r.passives.forEach(p=>{
        (p.trio||[]).forEach(x=>{
          const nm = x?.name || ''; if (!nm) return;
          const S = B.skills.get(nm) || { occ:0, appear:0, appearWins:0 };
          S.occ += 1; S.appear += 1; if (r.result==='W') S.appearWins += 1;
          B.skills.set(nm, S);
        });
      });
    } else { // bans
      const nm = r.banName; if (!nm) return;
      const S = B.skills.get(nm) || { occ:0, appear:0, appearWins:0 };
      S.occ += 1; S.appear += 1; if (r.result==='W') S.appearWins += 1;
      B.skills.set(nm, S);
    }
  });
  return B;
}
function topSkillsData(bucket, limit=10){
  if (!bucket || !bucket.matches) return [];
  return [...bucket.skills.entries()].map(([name, s])=>{
    return {
      skill: name,
      count: s.occ,
      appear: s.appear,
      pick_rate: bucket.matches ? s.appear/bucket.matches : 0,
      win_rate: s.appear ? s.appearWins/s.appear : 0
    };
  }).sort((a,b)=> b.pick_rate - a.pick_rate || a.skill.localeCompare(b.skill)).slice(0,limit);
}
function topSkillsTable(bucket, kind, limit=10){
  const skills = topSkillsData(bucket, limit);
  const rateLabel = (kind==='ban') ? 'Ban Rate' : 'Pick Rate';
  if (!skills.length) return `<div class="muted">No ${kind} data.</div>`;
  return `
    <table>
      <thead><tr><th>Skill</th><th class="right">Count</th><th class="right">${rateLabel}</th><th class="right">Win Rate</th></tr></thead>
      <tbody>
        ${skills.map(s=>`
          <tr><td>${s.skill}</td><td class="right">${s.count}</td><td class="right">${fmtPct(s.pick_rate)}</td><td class="right">${fmtPct(s.win_rate)}</td></tr>
        `).join('')}
      </tbody>
    </table>`;
}
function teamMapStatsData(rows){
  const agg = new Map();
  rows.forEach(r=>{
    const m = r.map || '—';
    if (!agg.has(m)) agg.set(m, { map:m, matches:0, wins:0 });
    const A = agg.get(m); A.matches += 1; if (r.result==='W') A.wins += 1;
  });
  return [...agg.values()].map(x=>({ ...x, winpct: x.matches? x.wins/x.matches : 0 }))
               .sort((a,b)=> b.matches - a.matches || b.winpct - a.winpct || a.map.localeCompare(b.map));
}
function teamMapStats(rows){
  const list = teamMapStatsData(rows);
  if (!list.length) return `<div class="muted">No team×map rows.</div>`;
  return `
    <table>
      <thead><tr><th>Map</th><th class="right">Matches</th><th class="right">Wins</th><th class="right">Win %</th></tr></thead>
      <tbody>
        ${list.map(r=>`<tr><td>${r.map}</td><td class="right">${r.matches}</td><td class="right">${r.wins}</td><td class="right">${fmtPct(r.winpct)}</td></tr>`).join('')}
      </tbody>
    </table>`;
}

/* ========= Render ========= */
function kpiCard(bucket, kindActive, kindPassive, kindBan){
  if (!bucket || !bucket.matches) return `<div class="muted">No data for selection.</div>`;
  const subjA = [...kindActive.skills.values()].reduce((a,s)=>(a.appear+=s.appear,a),{appear:0});
  const subjP = [...kindPassive.skills.values()].reduce((a,s)=>(a.appear+=s.appear,a),{appear:0});
  const subjB = [...kindBan.skills.values()].reduce((a,s)=>(a.appear+=s.appear,a),{appear:0});
  return `
    <div class="kpis">
      <div class="kpi">Matches <strong>${bucket.matches}</strong></div>
      <div class="kpi">Wins <strong>${bucket.wins}</strong> <span class="muted">(${pct(bucket.wins,bucket.matches)})</span></div>
      <div class="kpi">Active picks <strong>${subjA.appear}</strong> <span class="muted">(${pct(subjA.appear,bucket.matches)})</span></div>
      <div class="kpi">Passive picks <strong>${subjP.appear}</strong> <span class="muted">(${pct(subjP.appear,bucket.matches)})</span></div>
      <div class="kpi">Bans <strong>${subjB.appear}</strong> <span class="muted">(${pct(subjB.appear,bucket.matches)})</span></div>
    </div>`;
}

function renderAll(){
  const a = el('cmpTeamA').value, b = el('cmpTeamB').value;
  if (!a || !b || a===b){
    el('meta').textContent = 'Pick two different teams.';
    ['kpiA','kpiB','matchesA','matchesB'].forEach(id=>{ const t=el(id); if(t) t.innerHTML='<div class="muted">—</div>'; });
    return;
  }

  const mapLabel   = (el('fMap').value==='__ALL__')?'All maps':el('fMap').value;
  const tournLabel = (el('fTourn').value==='__ALL__')?'All tournaments':el('fTourn').value;
  const wlLabel    = (el('fWL').value==='__ALL__')?'All outcomes':(el('fWL').value==='W'?'Wins only':'Losses only');
  el('meta').textContent = `${a} vs ${b} • ${mapLabel} • ${tournLabel} • ${wlLabel}`;

  const rowsA = rowsForTeam(a), rowsB = rowsForTeam(b);

  const bA = buildTeamBucket(rowsA, a, 'active');
  const bP_A = buildTeamBucket(rowsA, a, 'passive');
  const bBan_A = buildTeamBucket(rowsA, a, 'ban');
  const bB = buildTeamBucket(rowsB, b, 'active');
  const bP_B = buildTeamBucket(rowsB, b, 'passive');
  const bBan_B = buildTeamBucket(rowsB, b, 'ban');

  el('kpiA').innerHTML = `<h3>${a}</h3>${kpiCard(bA, bA, bP_A, bBan_A)}`;
  el('kpiB').innerHTML = `<h3>${b}</h3>${kpiCard(bB, bB, bP_B, bBan_B)}`;

  el('labelMatchesA').textContent = a;
  el('labelMatchesB').textContent = b;
  el('matchesA').innerHTML = matchesTable(rowsA);
  el('matchesB').innerHTML = matchesTable(rowsB);

  // After the DOM is built, adapt density based on actual cell width
  requestAnimationFrame(adaptPlayersWrap);
}

/* ========= Populate + refresh ========= */
function populateTeamDropdowns(records){
  const teams = [...new Set(records.flatMap(r=>[r.team_left, r.team_right]).filter(Boolean))].sort();
  const A = el('cmpTeamA'), B = el('cmpTeamB');
  const prevA = A.value, prevB = B.value;
  const opts = teams.map(t=>`<option value="${t}">${t}</option>`).join('');
  A.innerHTML = opts; B.innerHTML = opts;
  A.value = teams.includes(prevA) ? prevA : (teams[0] || '');
  B.value = teams.includes(prevB) ? prevB : (teams[1] || teams[0] || '');
}

async function refresh(){
  RAW_RECORDS = await fetchRecords();
  await populateTournamentDropdown(RAW_RECORDS);
  populateTeamDropdowns(RAW_RECORDS);
  renderAll();
}

/* ========= Events ========= */
el('applyBtn').onclick = refresh;
['cmpTeamA','cmpTeamB'].forEach(id=> el(id).addEventListener('change', renderAll));
el('cmpSwap').addEventListener('click', ()=>{
  const A = el('cmpTeamA'), B = el('cmpTeamB'); const t = A.value; A.value = B.value; B.value = t; renderAll();
});
window.addEventListener('resize', adaptPlayersWrap);

/* ========= First load ========= */
refresh();
</script>
</body>
</html>
