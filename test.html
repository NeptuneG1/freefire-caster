<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Clash Squad — Skills per Match + Summary</title>

  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    const client = supabase.createClient(
      'https://gkugecflfddkpitlrmws.supabase.co',
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdrdWdlY2ZsZmRka3BpdGxybXdzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDYwODMwNzQsImV4cCI6MjA2MTY1OTA3NH0.OgQOx9k71DDdK1yOa7VNKGSgoFD9kNGo8j-bR91zGKE'
    );

    client.auth.getSession().then(({ data: { session } }) => {
      if (!session) {
        window.location.href = "index.html";
      } else {
        const userInfo = document.getElementById("user-info");
        if (userInfo && session.user?.email) {
          userInfo.textContent = "Logged in as: " + session.user.email;
        }
      }
    });

    function logout() {
      client.auth.signOut().then(() => {
        window.location.href = "index.html";
      });
    }
  </script>

  <!-- Fonts + Styles -->
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&family=Roboto&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0e0e0e;
      --panel: #1c1c1c;
      --panel-2: #1f1f1f;
      --text: #f5f5f5;
      --muted: #bbb;
      --muted-2: #888;
      --b: #444;
      --gold: #ffbd59;
      --accent: #ff7733;
      --danger: #ff5a5a;
      --row: #141414;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: 'Roboto', sans-serif; background: var(--bg); color: var(--text); }
    header { background: var(--panel-2); padding: 20px; text-align: center; border-bottom: 3px solid var(--gold); position: sticky; top: 0; z-index: 3; }
    h1 { margin: 0; font-family: 'Orbitron', sans-serif; color: var(--gold); font-size: 1.8rem; }
    .user-controls { position: absolute; top: 20px; right: 20px; display: flex; align-items: center; gap: 10px; }
    .user-controls #user-info { font-size: 14px; color: #ccc; }
    .btn { background: var(--gold); color: #1c1c1c; font-weight: bold; padding: 8px 12px; border: none; border-radius: 6px; cursor: pointer; }
    .btn:hover { background: #e0a84f; }
    a.btn { text-decoration: none; display: inline-block; }
    main { width: 95%; max-width: 1400px; margin: 18px auto 60px; }

    .toolbar { margin: 12px 0; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .toolbar .count { color: var(--muted); font-size: 13px; }

    .filters { background: var(--panel); border: 1px solid var(--b); border-radius: 10px; padding: 12px; display: grid; grid-template-columns: repeat(auto-fit,minmax(220px,1fr)); gap: 10px; }
    .filters label { display: flex; flex-direction: column; gap: 6px; font-size: 12px; color: var(--muted); }
    .filters input[type="date"], .filters select { background: #2a2a2a; color: var(--gold); border: 1px solid var(--b); border-radius: 6px; padding: 8px; }
    .filters .row { grid-column: 1/-1; display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .filters .pill { padding: 6px 8px; border: 1px dashed var(--b); border-radius: 6px; font-size: 12px; color: var(--muted); }

    .table-wrap { background: var(--panel); border: 1px solid var(--b); border-radius: 10px; overflow: hidden; }
    table { width: 100%; border-collapse: collapse; }
    thead th { position: sticky; top: 0; background: #181818; z-index: 1; }
    th, td { padding: 10px 8px; border-bottom: 1px solid #2a2a2a; text-align: left; font-size: 12.5px; vertical-align: top; }
    tbody tr:nth-child(odd) { background: var(--row); }
    .badge { display: inline-flex; align-items: center; gap: 6px; padding: 2px 6px; border-radius: 999px; font-size: 11px; font-weight: 700; }
    .win { background: #1d3f2a; color: #39d27d; border: 1px solid #2d6b47; }
    .loss { background: #3f1d1d; color: #ff8c8c; border: 1px solid #6b2d2d; }
    .ban { background: #2a2a2a; color: #f3cccc; border: 1px solid #533; }
    .ban-img { width: 18px; height: 18px; border-radius: 3px; border: 1px solid #333; background:#222; object-fit: cover; }

    .players { display: grid; grid-template-columns: repeat(4, minmax(140px,1fr)); gap: 8px; }
    .pbox { padding: 8px; background: #151515; border: 1px solid #2a2a2a; border-radius: 8px; }
    .pbox .p { color: var(--muted-2); font-size: 11px; margin-bottom: 4px; }
    .pbox .a { font-size: 12.5px; color: #fff; font-weight: 600; display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
    .pbox .pn { color: #cfd8dc; font-size: 11.5px; margin: 2px 0 6px; }
    .hero-img { width: 42px; height: 42px; border-radius: 6px; object-fit: cover; background: #222; border: 1px solid #333; }
    .passive-list { display: flex; flex-wrap: wrap; gap: 6px; }
    .passive-chip { display: inline-flex; align-items: center; gap: 6px; padding: 2px 6px; border: 1px solid #2a2a2a; border-radius: 999px; background: #101010; color: #bbb; }
    .passive-chip img { width: 14px; height: 14px; border-radius: 3px; object-fit: cover; background:#222; border: 1px solid #333; }

    .caps { text-transform: uppercase; letter-spacing: .4px; font-weight: 700; color: var(--muted); font-size: 11px; }
    .empty { text-align: center; padding: 30px; color: var(--muted); }

    /* ===== Summary section ===== */
    .sum-wrap { margin-top: 20px; }
    .sum-head { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: space-between; }
    .sum-head h2 { margin: 0; color: var(--gold); }
    .sum-controls { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .sum-controls select { background: #2a2a2a; color: var(--gold); border: 1px solid var(--b); border-radius: 6px; padding: 8px; }
    .sum-grid { display: grid; grid-template-columns: repeat(auto-fit,minmax(320px,1fr)); gap: 12px; margin-top: 12px; }
    .sum-card { background: var(--panel); border: 1px solid var(--b); border-radius: 10px; padding: 10px; }
    .sum-card h3 { margin: 0 0 8px 0; color: var(--accent); }
    .sum-table { width: 100%; border-collapse: collapse; }
    .sum-table th, .sum-table td { border-bottom: 1px solid #2a2a2a; padding: 6px; font-size: 12.5px; }
    .sum-table th { background: #181818; position: sticky; top: 0; }
    .skill-cell { display: inline-flex; align-items: center; gap: 8px; }
    .skill-cell img { width: 20px; height: 20px; border-radius: 4px; border: 1px solid #333; background:#222; object-fit: cover; }
    .muted { color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <header>
    <div class="user-controls">
      <span id="user-info">Checking login...</span>
      <button class="btn" onclick="logout()">Logout</button>
    </div>
    <h1>Skills per Match</h1>
  </header>

  <main>
    <div class="toolbar">
      <a class="btn" href="dashboard.html">← Back to Dashboard</a>
      <span class="count" id="rowCount">—</span>
    </div>

    <!-- Filters -->
    <section class="filters">
      <label>
        Team
        <select id="teamFilter">
          <option value="__ALL__">All teams</option>
        </select>
      </label>

      <label>
        Result
        <select id="resultFilter">
          <option value="__ALL__">All</option>
          <option value="Win">Win</option>
          <option value="Loss">Loss</option>
        </select>
      </label>

      <label>
        Map
        <select id="mapFilter">
          <option value="__ALL__">All maps</option>
          <option value="Bermuda">Bermuda</option>
          <option value="Kalahari">Kalahari</option>
          <option value="Purgatory">Purgatory</option>
          <option value="Alpine">Alpine</option>
          <option value="Nexterra">Nexterra</option>
          <option value="Solara">Solara</option>
        </select>
      </label>

      <label>
        From date
        <input type="date" id="fromDate">
      </label>

      <label>
        To date
        <input type="date" id="toDate">
      </label>

      <div class="row">
        <button class="btn" id="applyBtn">Apply Filters</button>
        <button class="btn" id="resetBtn" style="background:#2a2a2a;color:#fff;border:1px solid #444;">Reset</button>
      </div>
    </section>

    <!-- Skills per Match table -->
    <div class="table-wrap" style="margin-top:14px;">
      <table id="skillsTable">
        <thead>
          <tr>
            <th data-sort="date">Date</th>
            <th data-sort="game">Game</th>
            <th data-sort="map">Map</th>
            <th data-sort="team">Team</th>
            <th>Opponent</th>
            <th data-sort="result">Result</th>
            <th>Ban</th>
            <th style="min-width:560px;">Players (Actives, Passives & Names)</th>
          </tr>
        </thead>
        <tbody id="skillsBody">
          <tr><td class="empty" colspan="8">Loading…</td></tr>
        </tbody>
      </table>
    </div>

    <!-- ===== Summary Section ===== -->
    <section class="sum-wrap">
      <div class="sum-head">
        <h2>Summary: Picks/Bans</h2>
        <div class="sum-controls">
          <label class="muted">Group by
            <select id="sumGroupBy">
              <option value="team">Team</option>
              <option value="player">Player</option>
            </select>
          </label>
          <label class="muted">Subject
            <select id="sumKind">
              <option value="active">Active skills</option>
              <option value="passive">Passive skills</option>
              <option value="ban">Bans</option>
            </select>
          </label>
        </div>
      </div>

      <div id="sumMeta" class="muted" style="margin-top:6px;"></div>
      <div id="sumGrid" class="sum-grid" style="min-height:80px;">
        <!-- cards render here -->
      </div>
    </section>
  </main>

  <script>
    const PLACEHOLDER = 'https://imgur.com/AdvPwAO.png';
    let CHAR_INDEX = new Map(); // name -> { image_url, ... }

    // -------- Helpers --------
    function safe(obj, def = null) { return obj ?? def; }
    function byNameImg(name) {
      if (!name) return PLACEHOLDER;
      const c = CHAR_INDEX.get(name);
      return c?.image_url || PLACEHOLDER;
    }
    function pct(n, d) {
      if (!d || d === 0) return '—';
      return ((n / d) * 100).toFixed(1) + '%';
    }

    // Build a row object (one per team per match)
    function buildRow(record, side) {
      const s = safe(record.state, {});
      const picks = safe(s.picks, []);
      const passives = safe(s.passives, []);
      const playersArr = safe(s.playerCards, []); // player names
      const bans = safe(s.bans, []);

      const isLeft = side === 'left';
      const team = isLeft ? record.team_left : record.team_right;
      const opp  = isLeft ? record.team_right : record.team_left;
      const teamScore = isLeft ? (record.team_left_score ?? 0) : (record.team_right_score ?? 0);
      const oppScore  = isLeft ? (record.team_right_score ?? 0) : (record.team_left_score ?? 0);
      const result = teamScore > oppScore ? 'Win' : 'Loss';

      const banObj = bans[isLeft ? 0 : 1] || null;
      const banName = safe(banObj?.name, '—');
      const banImg  = safe(banObj?.image_url, null) || byNameImg(banName);

      // player indices
      const idx = isLeft ? [0,1,2,3] : [4,5,6,7];

      const players = idx.map((i, k) => {
        const activeName = safe(picks[i]?.name, 'None');
        const activeImg  = safe(picks[i]?.image_url, null) || byNameImg(activeName);
        const playerName = (playersArr[i] && String(playersArr[i]).trim()) ? String(playersArr[i]).trim() : '';

        const psList = (passives[i] || []).filter(Boolean).map(x => ({
          name: x.name,
          image: x.image_url || byNameImg(x.name)
        }));

        return {
          label: `P${k+1}`,
          playerName,
          activeName,
          activeImg,
          passives: psList
        };
      });

      return {
        id: record.id,
        date: record.match_date,
        game: record.game_number,
        map: record.map || '—',
        team,
        opponent: opp,
        result,
        banName,
        banImg,
        players
      };
    }

    function playerCellHTML(p) {
      const passHTML = p.passives.length
        ? `<div class="passive-list">${p.passives.map(ps => `
             <span class="passive-chip">
               <img src="${ps.image || PLACEHOLDER}" alt="">
               ${ps.name}
             </span>`).join('')}
           </div>`
        : `<div class="passive-list" style="color:#666;">—</div>`;

      return `
        <div class="pbox">
          <div class="p caps">${p.label}</div>
          ${p.playerName ? `<div class="pn">${p.playerName}</div>` : ``}
          <div class="a">
            <img class="hero-img" src="${p.activeImg || PLACEHOLDER}" alt="">
            <span>${p.activeName}</span>
          </div>
          ${passHTML}
        </div>
      `;
    }

    function rowHTML(r) {
      const badge = r.result === 'Win' ? 'win' : 'loss';
      return `
        <tr>
          <td>${r.date}</td>
          <td>G${r.game}</td>
          <td>${r.map}</td>
          <td><strong>${r.team}</strong></td>
          <td>${r.opponent}</td>
          <td><span class="badge ${badge}">${r.result}</span></td>
          <td><span class="badge ban"><img class="ban-img" src="${r.banImg || PLACEHOLDER}" alt=""> ${r.banName}</span></td>
          <td>
            <div class="players">
              ${r.players.map(playerCellHTML).join('')}
            </div>
          </td>
        </tr>
      `;
    }

    // -------- Data + filters --------
    let ALL_ROWS = [];
    let CURRENT_ROWS = [];
    let SORT_KEY = null;
    let SORT_ASC = true;

    function setDefaultDates() {
      const to = new Date();
      const from = new Date(to);
      from.setMonth(from.getMonth() - 3); // last ~90 days by default

      const toEl = document.getElementById('toDate');
      const fromEl = document.getElementById('fromDate');

      const fmt = d => d.toISOString().slice(0,10);
      toEl.value = fmt(to);
      fromEl.value = fmt(from);
    }

    async function loadCharacters() {
      try {
        const resp = await fetch('https://neptuneg1.github.io/freefire-caster/character.json');
        const list = await resp.json();
        CHAR_INDEX = new Map(list.map(c => [c.name, c]));
      } catch (e) {
        console.warn('Could not load character index for fallback images:', e);
        CHAR_INDEX = new Map();
      }
    }

    async function loadData() {
      const from = document.getElementById('fromDate').value;
      const to   = document.getElementById('toDate').value;

      let q = client
        .from('draft_records')
        .select('id, match_date, game_number, team_left, team_right, team_left_score, team_right_score, map, state')
        .order('match_date', { ascending: false })
        .order('id', { ascending: false });

      if (from) q = q.gte('match_date', from);
      if (to)   q = q.lte('match_date', to);

      const { data, error } = await q;
      const body = document.getElementById('skillsBody');

      if (error) {
        console.error('Fetch error:', error);
        body.innerHTML = `<tr><td class="empty" colspan="8">Failed to fetch data.</td></tr>`;
        return;
      }

      const rows = [];
      data.forEach(rec => {
        rows.push(buildRow(rec, 'left'));
        rows.push(buildRow(rec, 'right'));
      });

      ALL_ROWS = rows;

      // Build team dropdown from data (unique)
      const teamSet = new Set();
      rows.forEach(r => { if (r.team) teamSet.add(r.team); });
      const teamSel = document.getElementById('teamFilter');
      teamSel.innerHTML = `<option value="__ALL__">All teams</option>`;
      [...teamSet].sort().forEach(t => {
        const opt = document.createElement('option');
        opt.value = t;
        opt.textContent = t;
        teamSel.appendChild(opt);
      });

      applyFilters();
    }

    function applyFilters() {
      const team   = document.getElementById('teamFilter').value;
      const result = document.getElementById('resultFilter').value;
      const map    = document.getElementById('mapFilter').value;

      let rows = ALL_ROWS.slice();

      if (team !== '__ALL__')   rows = rows.filter(r => r.team === team);
      if (result !== '__ALL__') rows = rows.filter(r => r.result === result);
      if (map !== '__ALL__')    rows = rows.filter(r => r.map === map);

      if (SORT_KEY) {
        rows.sort((a,b) => {
          const A = a[SORT_KEY];
          const B = b[SORT_KEY];
          if (A == null && B == null) return 0;
          if (A == null) return 1;
          if (B == null) return -1;
          if (A < B) return SORT_ASC ? -1 : 1;
          if (A > B) return SORT_ASC ? 1 : -1;
          return 0;
        });
      }
      CURRENT_ROWS = rows;
      renderTable(rows);
      recomputeSummary(); // <— update summary with filtered rows
    }

    function renderTable(rows) {
      const body = document.getElementById('skillsBody');
      const count = document.getElementById('rowCount');
      count.textContent = `${rows.length} team-rows`;

      if (!rows.length) {
        body.innerHTML = `<tr><td class="empty" colspan="8">No rows match your filters.</td></tr>`;
        return;
      }
      body.innerHTML = rows.map(rowHTML).join('');
    }

    function resetFilters() {
      document.getElementById('teamFilter').value = '__ALL__';
      document.getElementById('resultFilter').value = '__ALL__';
      document.getElementById('mapFilter').value = '__ALL__';
      setDefaultDates();
      loadData();
    }

    // ===== Summary computation =====
    function recomputeSummary() {
      const groupBy = document.getElementById('sumGroupBy').value; // team | player
      const kind    = document.getElementById('sumKind').value;    // active | passive | ban
      const rows    = CURRENT_ROWS;

      // buckets: key -> { name, matches, wins, skills: Map(skill -> {occ, appear, appearWins, img}) }
      const buckets = new Map();

      rows.forEach(r => {
        if (groupBy === 'team') {
          aggregateForTeam(buckets, r, kind);
        } else {
          aggregateForPlayers(buckets, r, kind);
        }
      });

      renderSummary(buckets, groupBy, kind);
    }

    function ensureBucket(map, key, name) {
      if (!map.has(key)) map.set(key, { name, matches: 0, wins: 0, skills: new Map() });
      return map.get(key);
    }
    function ensureSkill(skMap, skill, img) {
      if (!skMap.has(skill)) skMap.set(skill, { occ: 0, appear: 0, appearWins: 0, img: img || byNameImg(skill) });
      return skMap.get(skill);
    }

    // Team-level aggregation
    function aggregateForTeam(buckets, r, kind) {
      const key = r.team;
      const b = ensureBucket(buckets, key, r.team);
      // one team-row = one match appearance for the team
      b.matches += 1;
      if (r.result === 'Win') b.wins += 1;

      const seen = new Set(); // track per-skill "appearance" within this team-row

      if (kind === 'active') {
        r.players.forEach(p => {
          const sName = p.activeName || 'None';
          if (!sName || sName === 'None') return;
          const sk = ensureSkill(b.skills, sName, p.activeImg);
          sk.occ += 1;
          if (!seen.has(sName)) {
            sk.appear += 1;
            if (r.result === 'Win') sk.appearWins += 1;
            seen.add(sName);
          }
        });
      } else if (kind === 'passive') {
        r.players.forEach(p => {
          p.passives.forEach(ps => {
            const sName = ps.name;
            if (!sName) return;
            const sk = ensureSkill(b.skills, sName, ps.image);
            sk.occ += 1;
            if (!seen.has(sName)) {
              sk.appear += 1;
              if (r.result === 'Win') sk.appearWins += 1;
              seen.add(sName);
            }
          });
        });
      } else { // ban
        const sName = r.banName;
        if (sName && sName !== '—') {
          const sk = ensureSkill(b.skills, sName, r.banImg);
          sk.occ += 1; // team has exactly 1 ban slot per team-row
          if (!seen.has(sName)) {
            sk.appear += 1;
            if (r.result === 'Win') sk.appearWins += 1;
            seen.add(sName);
          }
        }
      }
    }

    // Player-level aggregation
    function aggregateForPlayers(buckets, r, kind) {
      const playersProcessed = new Set(); // avoid counting same player twice in a row
      r.players.forEach(p => {
        const pname = (p.playerName || '').trim();
        if (!pname) return;

        const b = ensureBucket(buckets, pname, pname);

        // count one "match" for the player per team-row
        if (!playersProcessed.has(pname)) {
          b.matches += 1;
          if (r.result === 'Win') b.wins += 1;
          playersProcessed.add(pname);
        }

        const seen = b._seenPerRow || new Set(); // track appearances per player per row
        // To keep it simple, we still avoid double-appearance increments within this single row for this player
        if (kind === 'active') {
          const sName = p.activeName || 'None';
          if (sName && sName !== 'None') {
            const sk = ensureSkill(b.skills, sName, p.activeImg);
            sk.occ += 1;
            const apKey = 'A|' + sName + '|' + r.id;
            if (!seen.has(apKey)) {
              sk.appear += 1;
              if (r.result === 'Win') sk.appearWins += 1;
              seen.add(apKey);
            }
          }
        } else if (kind === 'passive') {
          p.passives.forEach(ps => {
            const sName = ps.name;
            if (!sName) return;
            const sk = ensureSkill(b.skills, sName, ps.image);
            sk.occ += 1;
            const apKey = 'P|' + sName + '|' + r.id;
            if (!seen.has(apKey)) {
              sk.appear += 1;
              if (r.result === 'Win') sk.appearWins += 1;
              seen.add(apKey);
            }
          });
        } else { // ban
          const sName = r.banName;
          if (sName && sName !== '—') {
            const sk = ensureSkill(b.skills, sName, r.banImg);
            sk.occ += 1; // counts ban in matches the player played
            const apKey = 'B|' + sName + '|' + r.id;
            if (!seen.has(apKey)) {
              sk.appear += 1;
              if (r.result === 'Win') sk.appearWins += 1;
              seen.add(apKey);
            }
          }
        }
        b._seenPerRow = seen;
      });
    }

    function renderSummary(buckets, groupBy, kind) {
      const grid = document.getElementById('sumGrid');
      const meta = document.getElementById('sumMeta');
      const totalEntities = buckets.size;
      const totalRows = CURRENT_ROWS.length;

      const rateLabel = (kind === 'ban') ? 'Ban Rate' : 'Pick Rate';
      meta.textContent = `${totalEntities} ${groupBy === 'team' ? 'team' : 'player'} group(s) • ${totalRows} team-row(s) in view`;

      if (!totalEntities) {
        grid.innerHTML = `<div class="sum-card"><div class="muted">No data for this selection.</div></div>`;
        return;
      }

      const cards = [];
      // sort entities by matches desc
      const ordered = [...buckets.values()].sort((a,b) => b.matches - a.matches);

      ordered.forEach(b => {
        const rows = [];
        // Header row
        rows.push(`
          <tr>
            <th>Skill</th>
            <th>Count</th>
            <th>${rateLabel}</th>
            <th>Win Rate</th>
          </tr>
        `);

        // sort skills by appearance desc then count desc
        const skills = [...b.skills.entries()]
          .sort((a,b) => (b[1].appear - a[1].appear) || (b[1].occ - a[1].occ));

        skills.forEach(([name, s]) => {
          const pr = pct(s.appear, b.matches);
          const wr = pct(s.appearWins, s.appear);
          rows.push(`
            <tr>
              <td>
                <span class="skill-cell">
                  <img src="${s.img || byNameImg(name)}" alt="">
                  ${name}
                </span>
              </td>
              <td>${s.occ}</td>
              <td>${pr}</td>
              <td>${wr}</td>
            </tr>
          `);
        });

        // If no skills, show placeholder
        const tableHTML = skills.length
          ? `<table class="sum-table"><thead>${rows[0]}</thead><tbody>${rows.slice(1).join('')}</tbody></table>`
          : `<div class="muted">No ${kind} data for this ${groupBy}.</div>`;

        cards.push(`
          <div class="sum-card">
            <h3>${b.name}</h3>
            <div class="muted" style="margin:-2px 0 8px 0;">
              Matches: ${b.matches} • Wins: ${b.wins} (${pct(b.wins, b.matches)})
            </div>
            ${tableHTML}
          </div>
        `);
      });

      grid.innerHTML = cards.join('');
    }

    // -------- UI wiring --------
    document.addEventListener('DOMContentLoaded', async () => {
      setDefaultDates();
      await loadCharacters();   // for fallback images if state is missing URLs
      await loadData();

      document.getElementById('applyBtn').addEventListener('click', applyFilters);
      document.getElementById('resetBtn').addEventListener('click', resetFilters);
      document.getElementById('teamFilter').addEventListener('change', applyFilters);
      document.getElementById('resultFilter').addEventListener('change', applyFilters);
      document.getElementById('mapFilter').addEventListener('change', applyFilters);
      document.getElementById('fromDate').addEventListener('change', loadData);
      document.getElementById('toDate').addEventListener('change', loadData);

      document.querySelectorAll('thead th[data-sort]').forEach(th => {
        th.style.cursor = 'pointer';
        th.title = 'Click to sort';
        th.addEventListener('click', () => {
          const key = th.getAttribute('data-sort');
          if (SORT_KEY === key) {
            SORT_ASC = !SORT_ASC;
          } else {
            SORT_KEY = key;
            SORT_ASC = true;
          }
          applyFilters();
        });
      });

      document.getElementById('sumGroupBy').addEventListener('change', recomputeSummary);
      document.getElementById('sumKind').addEventListener('change', recomputeSummary);
    });
  </script>
</body>
</html>
