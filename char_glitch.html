<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Char Glitch — 1440x3440</title>
  <style>
    :root{
      --W:1440px;
      --H:3440px;

      --hold-ms:10000;     /* 10 seconds */
      --glitch-ms:500;     /* glitch duration */

      /* Background “spice” tuning */
      --bg-intensity: .55;   /* 0.0 - 1.0 */
      --grid-opacity: .10;   /* subtle */
      --scan-opacity: .08;
      --vignette: .70;

      /* Theme colors (change these for different vibes) */
      --c1: rgba(70, 190, 255, 1);   /* cyan */
      --c2: rgba(255, 80, 180, 1);   /* magenta */
      --c3: rgba(255, 200, 80, 1);   /* warm amber */
      --c4: rgba(90, 120, 255, 1);   /* electric blue */

      --bg:#000;
    }

    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      overflow:hidden;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }

    .viewport{
      position:fixed; inset:0;
      display:grid; place-items:center;
      background:var(--bg);
    }

    .stage{
      width:var(--W);
      height:var(--H);
      position:relative;
      background:#000;
      overflow:hidden;
      transform-origin:center center;
      will-change: transform;
    }

    /* ===== Background FX (behind character) ===== */
    .bgWrap{
      position:absolute; inset:0;
      z-index:0;
      background:#05060a;
    }

    /* Aurora blob layer */
    .aurora{
      position:absolute; inset:-10%;
      opacity: calc(var(--bg-intensity) * 0.85);
      filter: blur(28px) saturate(1.25);
      mix-blend-mode: screen;
      background:
        radial-gradient(55% 35% at 20% 18%, var(--c1), transparent 65%),
        radial-gradient(45% 40% at 78% 22%, var(--c2), transparent 62%),
        radial-gradient(55% 45% at 35% 72%, var(--c4), transparent 64%),
        radial-gradient(55% 40% at 80% 78%, var(--c3), transparent 66%);
      animation: auroraDrift 18s ease-in-out infinite alternate;
      transform: translate3d(0,0,0);
    }

    @keyframes auroraDrift{
      0%   { transform: translate3d(-2%, -1.5%, 0) scale(1.02); filter: blur(26px) saturate(1.2); }
      50%  { transform: translate3d( 2.2%, 1.0%, 0) scale(1.06); filter: blur(30px) saturate(1.35); }
      100% { transform: translate3d(-1.5%, 2.2%, 0) scale(1.03); filter: blur(28px) saturate(1.25); }
    }

    /* Neon grid */
    .grid{
      position:absolute; inset:0;
      opacity: var(--grid-opacity);
      mix-blend-mode: overlay;
      background:
        linear-gradient(to right, rgba(255,255,255,.12) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(255,255,255,.10) 1px, transparent 1px);
      background-size: 84px 84px;
      animation: gridMove 14s linear infinite;
      filter: blur(.2px);
    }

    @keyframes gridMove{
      from { background-position: 0 0, 0 0; }
      to   { background-position: 84px 168px, 168px 84px; }
    }

    /* Subtle diagonal light sweep */
    .sweep{
      position:absolute; inset:-20%;
      opacity: calc(var(--bg-intensity) * 0.25);
      mix-blend-mode: screen;
      background:
        linear-gradient(120deg,
          transparent 0%,
          rgba(255,255,255,.05) 30%,
          rgba(255,255,255,.16) 45%,
          rgba(255,255,255,.06) 60%,
          transparent 80%);
      animation: sweep 9s ease-in-out infinite;
      filter: blur(6px);
    }
    @keyframes sweep{
      0%   { transform: translate3d(-10%, -6%, 0) rotate(1deg); }
      50%  { transform: translate3d( 6%,  2%, 0) rotate(-1deg); }
      100% { transform: translate3d(-6%,  6%, 0) rotate(1deg); }
    }

    /* Scanlines */
    .scan{
      position:absolute; inset:0;
      opacity: var(--scan-opacity);
      mix-blend-mode: overlay;
      background: repeating-linear-gradient(
        to bottom,
        rgba(0,0,0,.00) 0px,
        rgba(0,0,0,.00) 6px,
        rgba(0,0,0,.25) 7px
      );
      animation: scanDrift 7s linear infinite;
    }
    @keyframes scanDrift{
      from { transform: translateY(0); }
      to   { transform: translateY(18px); }
    }

    /* Vignette */
    .vignette{
      position:absolute; inset:0;
      opacity: var(--vignette);
      background: radial-gradient(70% 55% at 50% 40%, transparent 40%, rgba(0,0,0,.75) 100%);
      pointer-events:none;
    }

    /* Particles canvas (optional) */
    #fx{
      position:absolute; inset:0;
      width:100%; height:100%;
      z-index:1;
      pointer-events:none;
      opacity: calc(var(--bg-intensity) * 0.55);
      mix-blend-mode: screen;
    }

    /* ===== Image layers ===== */
    .layer{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover; object-position:center;
      user-select:none; -webkit-user-drag:none;
      pointer-events:none;
    }

    /* Ensure character layers are above background */
    #base{ z-index:2; }

    .glitchLayer{
      z-index:3;
      opacity:0;
      mix-blend-mode:screen;
      will-change: transform, opacity, filter, clip-path;
    }

    .slice{
      z-index:4;
      opacity:0;
      will-change: transform, opacity, clip-path, filter;
      position:absolute; left:0; right:0;
      height:14%;
    }
    #s1{ top:18%; }
    #s2{ top:46%; }
    #s3{ top:70%; }

    .glitching .glitchLayer,
    .glitching .slice{ opacity:1; }

    /* RGB split look */
    .r{ filter: drop-shadow(-8px 0 0 rgba(255,0,90,.95)); transform: translateX(-8px); }
    .g{ filter: drop-shadow( 8px 0 0 rgba(0,255,180,.85)); transform: translateX( 6px); }
    .b{ filter: drop-shadow( 0 0 0 rgba(90,120,255,.90)); transform: translateX(-2px); }

    /* Glitch animation */
    .glitching .r{ animation: glitchShiftR var(--glitch-ms) steps(2,end) 1; }
    .glitching .g{ animation: glitchShiftG var(--glitch-ms) steps(2,end) 1; }
    .glitching .b{ animation: glitchShiftB var(--glitch-ms) steps(2,end) 1; }

    .glitching #s1{ animation: glitchSlice1 var(--glitch-ms) steps(2,end) 1; }
    .glitching #s2{ animation: glitchSlice2 var(--glitch-ms) steps(2,end) 1; }
    .glitching #s3{ animation: glitchSlice3 var(--glitch-ms) steps(2,end) 1; }

    @keyframes glitchShiftR{
      0%{ transform:translate(-14px,-2px) skewX(0deg); opacity:.9; }
      20%{ transform:translate(-2px,1px) skewX(-3deg); }
      40%{ transform:translate(-18px,0) skewX(4deg); }
      60%{ transform:translate(-6px,-1px) skewX(-2deg); }
      80%{ transform:translate(-22px,2px) skewX(5deg); opacity:1; }
      100%{ transform:translate(-8px,0); opacity:0; }
    }
    @keyframes glitchShiftG{
      0%{ transform:translate(10px,1px) skewX(0deg); opacity:.85; }
      20%{ transform:translate(2px,-1px) skewX(3deg); }
      40%{ transform:translate(16px,2px) skewX(-4deg); }
      60%{ transform:translate(6px,0) skewX(2deg); }
      80%{ transform:translate(20px,-2px) skewX(-5deg); opacity:1; }
      100%{ transform:translate(6px,0); opacity:0; }
    }
    @keyframes glitchShiftB{
      0%{ transform:translate(-2px,0); opacity:.65; filter:contrast(1.15); }
      25%{ transform:translate(8px,-1px); }
      50%{ transform:translate(-10px,2px); filter:contrast(1.3); }
      75%{ transform:translate(4px,-2px); }
      100%{ transform:translate(-2px,0); opacity:0; filter:contrast(1.05); }
    }

    @keyframes glitchSlice1{
      0%{ opacity:0; transform:translateX(0); }
      10%{ opacity:1; transform:translateX(40px); }
      30%{ transform:translateX(-60px); }
      60%{ transform:translateX(30px); }
      100%{ opacity:0; transform:translateX(0); }
    }
    @keyframes glitchSlice2{
      0%{ opacity:0; transform:translateX(0); }
      15%{ opacity:1; transform:translateX(-50px); filter:brightness(1.1) contrast(1.2); }
      35%{ transform:translateX(70px); }
      70%{ transform:translateX(-20px); }
      100%{ opacity:0; transform:translateX(0); filter:none; }
    }
    @keyframes glitchSlice3{
      0%{ opacity:0; transform:translateX(0); }
      20%{ opacity:1; transform:translateX(30px); filter:saturate(1.2); }
      45%{ transform:translateX(-80px); }
      80%{ transform:translateX(25px); }
      100%{ opacity:0; transform:translateX(0); filter:none; }
    }

    /* Optional subtle grain on top */
    .grain{
      position:absolute; inset:0;
      z-index:5;
      pointer-events:none;
      opacity:.06;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='120' height='120' filter='url(%23n)' opacity='.55'/%3E%3C/svg%3E");
      background-size:220px 220px;
      mix-blend-mode:overlay;
    }

    /* Tiny debug HUD */
    #hud{
      position:absolute; left:18px; bottom:18px;
      z-index:6;
      padding:10px 12px;
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.15);
      border-radius:12px;
      color:#fff;
      font-size:13px;
      line-height:1.25;
      max-width:70%;
      pointer-events:none;
      backdrop-filter: blur(6px);
    }
    #hud small{opacity:.75}
  </style>
</head>

<body>
  <div class="viewport">
    <div class="stage" id="stage">

      <!-- Background FX -->
      <div class="bgWrap" aria-hidden="true">
        <div class="aurora"></div>
        <div class="sweep"></div>
        <div class="grid"></div>
        <div class="scan"></div>
        <div class="vignette"></div>
      </div>

      <canvas id="fx"></canvas>

      <!-- Character layers -->
      <img class="layer" id="base" alt="base" />
      <img class="layer glitchLayer r" id="glitchR" alt="r" />
      <img class="layer glitchLayer g" id="glitchG" alt="g" />
      <img class="layer glitchLayer b" id="glitchB" alt="b" />

      <img class="layer slice" id="s1" alt="slice1" />
      <img class="layer slice" id="s2" alt="slice2" />
      <img class="layer slice" id="s3" alt="slice3" />

      <div class="grain"></div>
      <div id="hud">Loading…</div>
    </div>
  </div>

  <script>
    const RAW_URLS = [
      "https://cdn.jsdelivr.net/gh/neptuneg1/freefire-caster@main/assets/chars/1.png",
      "https://cdn.jsdelivr.net/gh/neptuneg1/freefire-caster@main/assets/chars/2.png",
      "https://cdn.jsdelivr.net/gh/neptuneg1/freefire-caster@main/assets/chars/3.png",
      "https://cdn.jsdelivr.net/gh/neptuneg1/freefire-caster@main/assets/chars/4.png",
      "https://cdn.jsdelivr.net/gh/neptuneg1/freefire-caster@main/assets/chars/5.png",
      "https://cdn.jsdelivr.net/gh/neptuneg1/freefire-caster@main/assets/chars/6.png",
      "https://cdn.jsdelivr.net/gh/neptuneg1/freefire-caster@main/assets/chars/7.png"
    ];


    const HOLD_MS = 10000;
    const GLITCH_MS = 750;

    const stage = document.getElementById("stage");
    const hud   = document.getElementById("hud");

    const base  = document.getElementById("base");
    const gR    = document.getElementById("glitchR");
    const gG    = document.getElementById("glitchG");
    const gB    = document.getElementById("glitchB");
    const s1    = document.getElementById("s1");
    const s2    = document.getElementById("s2");
    const s3    = document.getElementById("s3");

    // ===== Stage scaling =====
    function fitStage(){
      const W = 1440, H = 3440;
      const vw = window.innerWidth, vh = window.innerHeight;
      const scale = Math.min(vw / W, vh / H);
      stage.style.transform = `scale(${scale})`;
    }
    window.addEventListener("resize", fitStage);

    // ===== Robust image loading =====
    function variants(url){
      // Try png/jpg/jpeg/webp if needed
      const u = new URL(url);
      const base = u.href.replace(/\.(png|jpg|jpeg|webp)(\?.*)?$/i, "");
      return [
        base + ".png",
        base + ".jpg",
        base + ".jpeg",
        base + ".webp",
        url
      ];
    }

    async function loadFirstWorking(url){
      const list = variants(url);
      for(const src of list){
        const ok = await new Promise(res=>{
          const img = new Image();
          img.onload = () => res(true);
          img.onerror = () => res(false);
          img.src = src + (src.includes("?") ? "&" : "?") + "v=" + Date.now(); // cache-bust
        });
        if(ok) return src;
      }
      return url;
    }

    async function resolveAll(urls){
      const out = [];
      for(let i=0;i<urls.length;i++){
        hud.textContent = `Resolving images… ${i+1}/${urls.length}`;
        out.push(await loadFirstWorking(urls[i]));
      }
      return out;
    }

    function setSrc(el, url){
      const sep = url.includes("?") ? "&" : "?";
      el.src = url + sep + "v=" + Date.now();
    }


    function randomSliceClip(){
      const left = Math.floor(Math.random()*10);
      const right = Math.floor(Math.random()*10);
      const top = Math.floor(Math.random()*6);
      const bottom = Math.floor(Math.random()*6);
      return `inset(${top}% ${right}% ${bottom}% ${left}%)`;
    }

    let idx = 0;
    let locked = false;
    let IMAGES = [];

    async function switchTo(nextUrl){
      if(locked) return;
      locked = true;

      const currentUrl = IMAGES[idx];

      // glitch out using current
      setSrc(gR, currentUrl); setSrc(gG, currentUrl); setSrc(gB, currentUrl);
      setSrc(s1, currentUrl); setSrc(s2, currentUrl); setSrc(s3, currentUrl);

      s1.style.clipPath = randomSliceClip();
      s2.style.clipPath = randomSliceClip();
      s3.style.clipPath = randomSliceClip();

      stage.classList.add("glitching");

      // mid-glitch: swap base to next
      setTimeout(()=>{
        setSrc(base, nextUrl);

        // glitch in using next
        setSrc(gR, nextUrl); setSrc(gG, nextUrl); setSrc(gB, nextUrl);
        setSrc(s1, nextUrl); setSrc(s2, nextUrl); setSrc(s3, nextUrl);

        s1.style.clipPath = randomSliceClip();
        s2.style.clipPath = randomSliceClip();
        s3.style.clipPath = randomSliceClip();
      }, Math.floor(GLITCH_MS * 0.35));

      setTimeout(()=>{
        stage.classList.remove("glitching");
        locked = false;
      }, GLITCH_MS + 40);
    }

    // ===== Particle background (very subtle) =====
    const fx = document.getElementById("fx");
    const ctx = fx.getContext("2d", { alpha: true });

    function sizeFX(){
      fx.width = 1440;
      fx.height = 3440;
    }

    const particles = [];
    function makeParticles(n=70){
      particles.length = 0;
      for(let i=0;i<n;i++){
        particles.push({
          x: Math.random()*fx.width,
          y: Math.random()*fx.height,
          vx: (Math.random()-.5)*0.25,
          vy: (Math.random()-.5)*0.25,
          r: 1.2 + Math.random()*2.6,
          a: 0.10 + Math.random()*0.18,
          h: Math.random()<0.5 ? 190 : 315 // cyan/magenta-ish hues
        });
      }
    }

    function tickParticles(){
      ctx.clearRect(0,0,fx.width,fx.height);
      ctx.globalCompositeOperation = "lighter";

      for(const p of particles){
        p.x += p.vx; p.y += p.vy;

        if(p.x < -30) p.x = fx.width + 30;
        if(p.x > fx.width + 30) p.x = -30;
        if(p.y < -30) p.y = fx.height + 30;
        if(p.y > fx.height + 30) p.y = -30;

        const grad = ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*6);
        grad.addColorStop(0, `hsla(${p.h}, 95%, 65%, ${p.a})`);
        grad.addColorStop(1, `hsla(${p.h}, 95%, 65%, 0)`);
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r*6, 0, Math.PI*2);
        ctx.fill();
      }

      ctx.globalCompositeOperation = "source-over";
      requestAnimationFrame(tickParticles);
    }

    async function start(){
      fitStage();
      sizeFX();
      makeParticles(70);
      tickParticles();

      IMAGES = await resolveAll(RAW_URLS);

      setSrc(base, IMAGES[0]);
      idx = 0;

      hud.innerHTML = `Running • <small>${IMAGES.length} images • hold ${HOLD_MS/1000}s • glitch ${GLITCH_MS}ms</small>`;

      setInterval(async ()=>{
        const nextIdx = (idx + 1) % IMAGES.length;
        await switchTo(IMAGES[nextIdx]);
        idx = nextIdx;
      }, HOLD_MS);
    }

    start();
  </script>
</body>
</html>
