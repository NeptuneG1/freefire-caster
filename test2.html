<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>FFBR — Elimination Relationships (Team vs Eliminator)</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" />
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  :root{
    --bg:#0d1014; --panel:#1b2130; --panel2:#121724;
    --ink:#eef3fb; --muted:#b6c0ce; --line:#313849;
    --brand:#ffe93b; --accent:#7fd2ff; --good:#62e887; --bad:#ff6b6b;
    --chip:#243142;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);
    font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif}
  a{color:var(--accent);text-decoration:none}
  a:hover{text-decoration:underline}

  header{position:sticky;top:0;z-index:20;background:linear-gradient(180deg,#121724 0%,#0d1014 100%);border-bottom:2px solid var(--brand)}
  .head{max-width:1200px;margin:0 auto;padding:14px 16px;display:flex;gap:14px;align-items:center;flex-wrap:wrap}
  .title{font-weight:800;font-size:18px;letter-spacing:.2px}
  .filters{display:flex;flex-wrap:wrap;gap:10px; margin-left:auto}
  .select, .input{
    background:#0f1420;border:1px solid var(--line);color:var(--ink);
    border-radius:10px;padding:8px 10px;min-width:120px
  }
  .chiprow{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
  .chip{
    background:var(--chip);border:1px solid var(--line);color:var(--ink);
    border-radius:999px;padding:6px 10px;font-size:12px
  }

  main{max-width:1200px;margin:18px auto;padding:0 16px 60px}
  h2{margin:22px 0 10px;font-size:18px}
  section{background:var(--panel);border:1px solid var(--line); border-radius:16px;padding:14px;margin:16px 0}
  .grid{display:grid;gap:14px}
  .grid-2{grid-template-columns:1fr 1fr}
  .grid-3{grid-template-columns:1fr 1fr 1fr}
  @media (max-width: 980px){
    .grid-2,.grid-3{grid-template-columns:1fr}
  }

  /* Matrix */
  .matrix-wrap{overflow:auto;border:1px solid var(--line);border-radius:12px; background:var(--panel2)}
  table{border-collapse:separate;border-spacing:0;width:max-content;min-width:100%}
  th,td{padding:8px 10px;border-right:1px solid var(--line);border-bottom:1px solid var(--line);text-align:center;font-size:12px;white-space:nowrap}
  th{position:sticky;top:0;background:#141a29;font-weight:700;z-index:5}
  th.sticky-left, td.sticky-left{position:sticky;left:0;background:#151a28;z-index:4;text-align:left}
  td.sticky-left{font-weight:600}
  tr:last-child td{border-bottom:none}
  td:last-child, th:last-child{border-right:none}
  .heat-0{background:#141a29}
  .heat-1{background:#18223b}
  .heat-2{background:#1b2745}
  .heat-3{background:#203158}
  .heat-4{background:#253a6a}
  .heat-5{background:#2a447d}
  .heat-6{background:#2f4d8f}
  .heat-7{background:#3557a2}
  .heat-8{background:#3b61b5}
  .heat-9{background:#416bc8}

  /* Tables */
  .tbl{width:100%;overflow:auto;border:1px solid var(--line);border-radius:12px;background:var(--panel2)}
  .tbl table{min-width:760px}
  .tbl th{cursor:pointer}
  .muted{color:var(--muted)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
  .right{text-align:right}
  .center{text-align:center}

  .note{font-size:12px;color:var(--muted);margin-top:8px}
  .tag{display:inline-block;border:1px solid var(--line);padding:2px 6px;border-radius:6px;background:#101626;margin-left:6px;font-size:11px}
  .highlight{outline:2px solid var(--accent)}
</style>
</head>
<body>
<header>
  <div class="head">
    <div class="title">FFBR — Team Eliminations Viewer</div>
    <div class="filters">
      <select id="daySel" class="select"></select>
      <select id="mapSel" class="select"></select>
      <input id="teamSearch" class="input" placeholder="Focus team (e.g., FX)" />
      <select id="viewSel" class="select">
        <option value="count" selected>Show: Counts</option>
        <option value="rowpct">Show: % of team’s eliminations suffered</option>
      </select>
    </div>
    <div class="chiprow" id="chips"></div>
  </div>
</header>

<main>
  <section>
    <h2>Head-to-Head Elimination Matrix <span class="tag">rows = eliminated teams</span> <span class="tag">columns = eliminators</span></h2>
    <div class="matrix-wrap" id="matrixWrap"></div>
    <div class="note">Tip: Filter by <b>Day</b>, <b>Map</b>, or both. Hover cells for detail. Use “% of team’s eliminations suffered” to normalize each row.</div>
  </section>

  <div class="grid grid-2">
    <section>
      <h2>Who Eliminated Each Team? (by filter)</h2>
      <div class="tbl" id="eliminatedByTbl"></div>
    </section>
    <section>
      <h2>Who Did Each Team Eliminate? (by filter)</h2>
      <div class="tbl" id="eliminationsGivenTbl"></div>
    </section>
  </div>

  <section>
    <h2>Team Summary — Placements, Booyahs, Kills</h2>
    <div class="tbl" id="teamSummaryTbl"></div>
    <div class="note">Derived from team-level rows only (1 row per team per match). “Matches” respects the current Day/Map filter.</div>
  </section>

  <section>
    <h2>Quick Insights (for analysts)</h2>
    <ul id="insights" style="margin:8px 0 0 18px; line-height:1.6">
      <!-- filled by JS -->
    </ul>
  </section>
</main>

<script>
const CSV_PATH = 'ffbr_lopsdata_rows.csv'; // keep this file next to the CSV

// Utility: number formatting
const fmt = (n, d=0) => isFinite(n) ? Number(n).toLocaleString(undefined,{maximumFractionDigits:d,minimumFractionDigits:d}) : '—';
const pct = (num, den) => den>0 ? ((num/den)*100) : 0;

// Globals
let raw = [];
let teamRows = []; // 1 row per team per match (includes booyah rows even if not eliminated)
let teams = [];
let days = [];
let maps = [];

// Filters
const daySel = document.getElementById('daySel');
const mapSel = document.getElementById('mapSel');
const teamSearch = document.getElementById('teamSearch');
const viewSel = document.getElementById('viewSel');
const chips = document.getElementById('chips');

// Targets
const matrixWrap = document.getElementById('matrixWrap');
const eliminatedByTbl = document.getElementById('eliminatedByTbl');
const eliminationsGivenTbl = document.getElementById('eliminationsGivenTbl');
const teamSummaryTbl = document.getElementById('teamSummaryTbl');
const insightsEl = document.getElementById('insights');

// Parse & boot
Papa.parse(CSV_PATH, {
  download:true, header:true, dynamicTyping:true, skipEmptyLines:true,
  complete: (res)=>{
    raw = res.data;
    // Detect team-level rows: have placement OR booyah-by-team OR eliminator filled
    teamRows = raw.filter(r =>
      (r['Ranking Placement'] !== null && r['Ranking Placement'] !== '' && !Number.isNaN(r['Ranking Placement'])) ||
      (r['Booyah By Team'] !== null && r['Booyah By Team'] !== '' && !Number.isNaN(r['Booyah By Team'])) ||
      (r['Eliminated Team Name'] && (r['Eliminated Team Name']+'').trim() !== '')
    );

    // Normalize types
    teamRows.forEach(r=>{
      r.Day = +r.Day; r.Match = +r.Match;
      r.MAP = (r.MAP||'').toString().trim();
      r.TeamName = (r.TeamName||'').toString().trim();
      r['Eliminated Team Name'] = (r['Eliminated Team Name']||'').toString().trim();
      r['Ranking Placement'] = +r['Ranking Placement'];
      r['Booyah By Team'] = +r['Booyah By Team'];
      r['Total Kill'] = +r['Total Kill'];
    });

    teams = Array.from(new Set(teamRows.map(r=>r.TeamName))).sort();
    days  = ['All', ...Array.from(new Set(teamRows.map(r=>r.Day))).sort((a,b)=>a-b)];
    maps  = ['All', ...Array.from(new Set(teamRows.map(r=>r.MAP))).sort()];

    // Build filters
    daySel.innerHTML = days.map(d=>`<option value="${d}">${d==='All'?'All Days':'Day '+d}</option>`).join('');
    mapSel.innerHTML = maps.map(m=>`<option value="${m}">${m==='All'?'All Maps':m}</option>`).join('');
    // Defaults: All
    daySel.value='All'; mapSel.value='All';

    [daySel, mapSel, viewSel].forEach(el=>el.addEventListener('change', renderAll));
    teamSearch.addEventListener('input', renderAll);

    renderAll();
  }
});

// Get filtered rows
function getFiltered(){
  const d = daySel.value;
  const m = mapSel.value;
  return teamRows.filter(r =>
    (d==='All' || r.Day==+d) &&
    (m==='All' || r.MAP===m)
  );
}

function summarize(filtered){
  const byTeam = Object.fromEntries(teams.map(t=>[t,[]]));
  filtered.forEach(r=> byTeam[r.TeamName]?.push(r));

  const rowsWithEliminator = filtered.filter(r=>r['Eliminated Team Name']);
  const matrix = {}; // matrix[eliminated][eliminator] = count
  const elimSuffered = {}; // suffered per team (as eliminated)
  const elimGiven = {}; // inflicted per team (as eliminator)

  rowsWithEliminator.forEach(r=>{
    const victim = r.TeamName;
    const killer = r['Eliminated Team Name'];
    matrix[victim] ||= {};
    matrix[victim][killer] = (matrix[victim][killer]||0)+1;
    elimSuffered[victim] = (elimSuffered[victim]||0)+1;
    elimGiven[killer] = (elimGiven[killer]||0)+1;
  });

  // Team summaries
  const teamSummary = teams.map(t=>{
    const rows = byTeam[t];
    const matches = rows.length;
    const booyah = rows.reduce((a,b)=>a + (Number(b['Booyah By Team'])||0), 0);
    const placeArr = rows.map(r=>Number(r['Ranking Placement'])).filter(v=>isFinite(v));
    const avgPlace = placeArr.length ? (placeArr.reduce((a,b)=>a+b,0)/placeArr.length) : NaN;
    const medPlace = placeArr.length ? percentile(placeArr.sort((a,b)=>a-b), 50) : NaN;
    const bestPlace = placeArr.length ? Math.min(...placeArr) : NaN;
    const totalKills = rows.reduce((a,b)=>a + (Number(b['Total Kill'])||0), 0);
    const kpm = matches ? totalKills/matches : 0;
    return {team:t, matches, booyah, avgPlace, medPlace, bestPlace, totalKills, kpm,
            suffered: elimSuffered[t]||0, given: elimGiven[t]||0};
  });

  return {matrix, elimSuffered, elimGiven, teamSummary};
}

function percentile(arr, p){
  if(!arr.length) return NaN;
  const idx = (p/100)*(arr.length-1);
  const lo = Math.floor(idx), hi = Math.ceil(idx);
  if(lo===hi) return arr[lo];
  const w = idx - lo;
  return arr[lo]*(1-w) + arr[hi]*w;
}

function heatClass(v, max){
  if(!max || v<=0) return 'heat-0';
  const bucket = Math.min(9, Math.floor((v/max)*9));
  return `heat-${bucket}`;
}

function renderMatrix(matrix, view){
  // Build column order as all teams
  const cols = teams.slice();
  const rows = teams.slice();
  // find max count for heat scale
  let max = 0;
  rows.forEach(v=>{
    cols.forEach(k=>{
      const val = (matrix[v]&&matrix[v][k])||0;
      max = Math.max(max, val);
    });
  });

  // Row totals for percentage mode
  const rowTotals = {};
  rows.forEach(v=>{
    rowTotals[v] = Object.values(matrix[v]||{}).reduce((a,b)=>a+b,0);
  });

  let html = '<table><thead><tr><th class="sticky-left">Eliminated ↓ / Eliminator →</th>';
  cols.forEach(c=> html += `<th title="${c}">${c}</th>`);
  html += '</tr></thead><tbody>';

  rows.forEach(r=>{
    html += `<tr><td class="sticky-left">${r}</td>`;
    cols.forEach(c=>{
      const count = (matrix[r]&&matrix[r][c])||0;
      const value = (view==='rowpct' && rowTotals[r]>0) ? (pct(count,rowTotals[r]).toFixed(0)+'%') : count;
      const cls = heatClass(count, max);
      const tip = `${c} eliminated ${r} ${count} time${count===1?'':'s'}`;
      html += `<td class="${cls}">${value||''}<div title="${tip}"></div></td>`;
    });
    html += '</tr>';
  });

  html += '</tbody></table>';
  matrixWrap.innerHTML = html;

  // Focus highlight
  const focus = (teamSearch.value||'').trim().toUpperCase();
  if(focus){
    Array.from(matrixWrap.querySelectorAll('table tr')).forEach(tr=>{
      if(tr.firstChild && tr.firstChild.textContent.toUpperCase()===focus){
        tr.classList.add('highlight');
      }
    });
    // highlight column header if matches
    const ths = matrixWrap.querySelectorAll('thead th');
    ths.forEach((th,idx)=>{
      if(idx>0 && th.textContent.toUpperCase()===focus) th.classList.add('highlight');
    });
  }
}

function renderEliminatedBy(matrix, elimSuffered){
  // For each team (row), list top eliminators
  const rows = teams.map(t=>{
    const row = matrix[t]||{};
    const entries = Object.entries(row).sort((a,b)=>b[1]-a[1]);
    const total = elimSuffered[t]||0;
    const top3 = entries.slice(0,3).map(([k,v])=>`${k} ${fmt(v)} (${fmt(pct(v,total),0)}%)`).join(' · ');
    return {team:t, times: total, top3, raw:entries};
  }).sort((a,b)=>b.times-a.times);

  let html = `<table>
    <thead><tr>
      <th class="sticky-left">Team</th>
      <th class="right">Times Eliminated</th>
      <th>Top Eliminators</th>
    </tr></thead><tbody>`;
  rows.forEach(r=>{
    html += `<tr>
      <td class="sticky-left">${r.team}</td>
      <td class="right mono">${fmt(r.times)}</td>
      <td>${r.top3||'<span class="muted">—</span>'}</td>
    </tr>`;
  });
  html += '</tbody></table>';
  eliminatedByTbl.innerHTML = html;
}

function renderEliminationsGiven(matrix){
  // Invert matrix into eliminator -> victims
  const given = {};
  teams.forEach(v=>{
    const row = matrix[v]||{};
    Object.entries(row).forEach(([killer,count])=>{
      given[killer] ||= {};
      given[killer][v] = (given[killer][v]||0)+count;
    });
  });

  const rows = teams.map(t=>{
    const entries = Object.entries(given[t]||{}).sort((a,b)=>b[1]-a[1]);
    const total = entries.reduce((a,b)=>a+b[1],0);
    const top3 = entries.slice(0,3).map(([k,v])=>`${k} ${fmt(v)}`).join(' · ');
    return {team:t, total, top3};
  }).sort((a,b)=>b.total-a.total);

  let html = `<table>
    <thead><tr>
      <th class="sticky-left">Eliminator</th>
      <th class="right">Eliminations Given</th>
      <th>Top Victims</th>
    </tr></thead><tbody>`;
  rows.forEach(r=>{
    html += `<tr>
      <td class="sticky-left">${r.team}</td>
      <td class="right mono">${fmt(r.total)}</td>
      <td>${r.top3||'<span class="muted">—</span>'}</td>
    </tr>`;
  });
  html += '</tbody></table>';
  eliminationsGivenTbl.innerHTML = html;
}

function renderTeamSummary(rows, teamSummary){
  // Sort by matches desc, then avg placement asc
  const sorted = teamSummary.slice().sort((a,b)=>{
    if(b.matches!==a.matches) return b.matches-a.matches;
    // better avg (lower) first
    return (a.avgPlace||99) - (b.avgPlace||99);
  });

  let html = `<table>
    <thead><tr>
      <th class="sticky-left">Team</th>
      <th class="right">Matches</th>
      <th class="right">Booyahs</th>
      <th class="right">Avg Place</th>
      <th class="right">Med Place</th>
      <th class="right">Best</th>
      <th class="right">Total Kills</th>
      <th class="right">Kills / Match</th>
      <th class="right">Times Eliminated</th>
      <th class="right">Elims Given</th>
    </tr></thead><tbody>`;
  sorted.forEach(r=>{
    html += `<tr>
      <td class="sticky-left">${r.team}</td>
      <td class="right mono">${fmt(r.matches)}</td>
      <td class="right mono">${fmt(r.booyah)}</td>
      <td class="right mono">${isFinite(r.avgPlace)? fmt(r.avgPlace,2):'—'}</td>
      <td class="right mono">${isFinite(r.medPlace)? fmt(r.medPlace,1):'—'}</td>
      <td class="right mono">${isFinite(r.bestPlace)? fmt(r.bestPlace):'—'}</td>
      <td class="right mono">${fmt(r.totalKills)}</td>
      <td class="right mono">${fmt(r.kpm,2)}</td>
      <td class="right mono">${fmt(r.suffered)}</td>
      <td class="right mono">${fmt(r.given)}</td>
    </tr>`;
  });
  html += '</tbody></table>';
  teamSummaryTbl.innerHTML = html;
}

function renderChips(filtered, matrixSummary){
  const matches = new Set(filtered.map(r=>`${r.Day}-${r.Match}`)).size;
  const uniqTeams = new Set(filtered.map(r=>r.TeamName)).size;
  const booyahRows = filtered.filter(r=>Number(r['Booyah By Team'])>0);
  const booyahTeams = booyahRows.map(r=>r.TeamName);

  // Find top predator and most hunted
  const givenEntries = Object.entries(matrixSummary.elimGiven).sort((a,b)=>b[1]-a[1]);
  const sufferedEntries = Object.entries(matrixSummary.elimSuffered).sort((a,b)=>b[1]-a[1]);

  chips.innerHTML = `
    <div class="chip">Matches: <b>${fmt(matches)}</b></div>
    <div class="chip">Teams in view: <b>${fmt(uniqTeams)}</b></div>
    <div class="chip">Booyah winners: <b>${booyahTeams.join(', ')||'—'}</b></div>
    <div class="chip">Top predator: <b>${(givenEntries[0]||['—','0'])[0]}</b> (${fmt((givenEntries[0]||['','0'])[1])})</div>
    <div class="chip">Most hunted: <b>${(sufferedEntries[0]||['—','0'])[0]}</b> (${fmt((sufferedEntries[0]||['','0'])[1])})</div>
  `;
}

function renderInsights(filtered, matrix){
  const rows = filtered;
  if(!rows.length){ insightsEl.innerHTML = '<li class="muted">No data in this slice.</li>'; return; }

  // Strongest H2H pairs
  const pairCounts = [];
  teams.forEach(v=>{
    const row = matrix[v]||{};
    Object.entries(row).forEach(([killer,count])=>{
      if(count>0) pairCounts.push({killer, victim:v, count});
    });
  });
  pairCounts.sort((a,b)=>b.count-a.count);
  const topPair = pairCounts[0];

  // Map bias: which map has the most eliminations in this slice
  const elimRows = rows.filter(r=>r['Eliminated Team Name']);
  const mapBias = Object.entries(elimRows.reduce((m,r)=>(m[r.MAP]=(m[r.MAP]||0)+1,m),{}))
                      .sort((a,b)=>b[1]-a[1])[0];

  // Day bias
  const dayBias = Object.entries(elimRows.reduce((m,r)=>(m[r.Day]=(m[r.Day]||0)+1,m),{}))
                      .sort((a,b)=>b[1]-a[1])[0];

  insightsEl.innerHTML = `
    <li><b>Strongest predator→prey relationship:</b> ${topPair ? `<b>${topPair.killer}</b> → <b>${topPair.victim}</b> (${fmt(topPair.count)} eliminations)` : '—'}</li>
    <li><b>Eliminations by map (top):</b> ${mapBias ? `<b>${mapBias[0]}</b> (${fmt(mapBias[1])})` : '—'}</li>
    <li><b>Eliminations by day (top):</b> ${dayBias ? `<b>Day ${dayBias[0]}</b> (${fmt(dayBias[1])})` : '—'}</li>
    <li><b>Analyst note:</b> Use the matrix <i>% view</i> to spot teams whose eliminations cluster against a single opponent (exposure risk). Cross-check with <i>Team Summary</i> for low avg placement + high “Times Eliminated”.</li>
  `;
}

function renderAll(){
  const filtered = getFiltered();
  const summ = summarize(filtered);

  renderChips(filtered, summ);
  renderMatrix(summ.matrix, viewSel.value);
  renderEliminatedBy(summ.matrix, summ.elimSuffered);
  renderEliminationsGiven(summ.matrix);
  renderTeamSummary(filtered, summ.teamSummary);
  renderInsights(filtered, summ.matrix);
}
</script>
</body>
</html>
